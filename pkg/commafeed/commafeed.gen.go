// Package commafeed provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.16.2 DO NOT EDIT.
package commafeed

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

const (
	BasicAuthScopes = "basicAuth.Scopes"
)

// Defines values for ApplicationSettingsCache.
const (
	NOOP  ApplicationSettingsCache = "NOOP"
	REDIS ApplicationSettingsCache = "REDIS"
)

// Defines values for SettingsExternalLinkIconDisplayMode.
const (
	SettingsExternalLinkIconDisplayModeAlwaysneveronDesktoponMobile SettingsExternalLinkIconDisplayMode = "always,never,on_desktop,on_mobile"
)

// Defines values for SettingsReadingMode.
const (
	Allunread SettingsReadingMode = "all,unread"
)

// Defines values for SettingsReadingOrder.
const (
	Ascdesc SettingsReadingOrder = "asc,desc"
)

// Defines values for SettingsScrollMode.
const (
	AlwaysneverifNeeded SettingsScrollMode = "always,never,if_needed"
)

// Defines values for SettingsStarIconDisplayMode.
const (
	SettingsStarIconDisplayModeAlwaysneveronDesktoponMobile SettingsStarIconDisplayMode = "always,never,on_desktop,on_mobile"
)

// Defines values for GetCategoryEntriesParamsReadType.
const (
	GetCategoryEntriesParamsReadTypeAll    GetCategoryEntriesParamsReadType = "all"
	GetCategoryEntriesParamsReadTypeUnread GetCategoryEntriesParamsReadType = "unread"
)

// Defines values for GetCategoryEntriesParamsOrder.
const (
	GetCategoryEntriesParamsOrderAsc  GetCategoryEntriesParamsOrder = "asc"
	GetCategoryEntriesParamsOrderDesc GetCategoryEntriesParamsOrder = "desc"
)

// Defines values for GetCategoryEntriesAsFeedParamsReadType.
const (
	GetCategoryEntriesAsFeedParamsReadTypeAll    GetCategoryEntriesAsFeedParamsReadType = "all"
	GetCategoryEntriesAsFeedParamsReadTypeUnread GetCategoryEntriesAsFeedParamsReadType = "unread"
)

// Defines values for GetCategoryEntriesAsFeedParamsOrder.
const (
	GetCategoryEntriesAsFeedParamsOrderAsc  GetCategoryEntriesAsFeedParamsOrder = "asc"
	GetCategoryEntriesAsFeedParamsOrderDesc GetCategoryEntriesAsFeedParamsOrder = "desc"
)

// Defines values for GetFeedEntriesParamsReadType.
const (
	GetFeedEntriesParamsReadTypeAll    GetFeedEntriesParamsReadType = "all"
	GetFeedEntriesParamsReadTypeUnread GetFeedEntriesParamsReadType = "unread"
)

// Defines values for GetFeedEntriesParamsOrder.
const (
	GetFeedEntriesParamsOrderAsc  GetFeedEntriesParamsOrder = "asc"
	GetFeedEntriesParamsOrderDesc GetFeedEntriesParamsOrder = "desc"
)

// Defines values for GetFeedEntriesAsFeedParamsReadType.
const (
	GetFeedEntriesAsFeedParamsReadTypeAll    GetFeedEntriesAsFeedParamsReadType = "all"
	GetFeedEntriesAsFeedParamsReadTypeUnread GetFeedEntriesAsFeedParamsReadType = "unread"
)

// Defines values for GetFeedEntriesAsFeedParamsOrder.
const (
	GetFeedEntriesAsFeedParamsOrderAsc  GetFeedEntriesAsFeedParamsOrder = "asc"
	GetFeedEntriesAsFeedParamsOrderDesc GetFeedEntriesAsFeedParamsOrder = "desc"
)

// AddCategoryRequest Add Category Request
type AddCategoryRequest struct {
	// Name name
	Name string `json:"name"`

	// ParentId parent category id, if any
	ParentId *string `json:"parentId,omitempty"`
}

// AdminSaveUserRequest Save User information
type AdminSaveUserRequest struct {
	// Admin user is admin
	Admin bool `json:"admin"`

	// Email user email, if any
	Email *string `json:"email,omitempty"`

	// Enabled account status
	Enabled bool `json:"enabled"`

	// Id user id
	Id *int64 `json:"id,omitempty"`

	// Name user name
	Name string `json:"name"`

	// Password user password
	Password *string `json:"password,omitempty"`
}

// ApplicationSettings defines model for ApplicationSettings.
type ApplicationSettings struct {
	AllowRegistrations          bool                     `json:"allowRegistrations"`
	Announcement                *string                  `json:"announcement,omitempty"`
	BackgroundThreads           int32                    `json:"backgroundThreads"`
	Cache                       ApplicationSettingsCache `json:"cache"`
	CreateDemoAccount           bool                     `json:"createDemoAccount"`
	DatabaseCleanupBatchSize    int32                    `json:"databaseCleanupBatchSize"`
	DatabaseUpdateThreads       int32                    `json:"databaseUpdateThreads"`
	GoogleAnalyticsTrackingCode *string                  `json:"googleAnalyticsTrackingCode,omitempty"`
	GoogleAuthKey               *string                  `json:"googleAuthKey,omitempty"`
	GraphiteEnabled             *bool                    `json:"graphiteEnabled,omitempty"`
	GraphiteHost                *string                  `json:"graphiteHost,omitempty"`
	GraphiteInterval            *int32                   `json:"graphiteInterval,omitempty"`
	GraphitePort                *int32                   `json:"graphitePort,omitempty"`
	GraphitePrefix              *string                  `json:"graphitePrefix,omitempty"`
	HeavyLoad                   bool                     `json:"heavyLoad"`
	HideFromWebCrawlers         bool                     `json:"hideFromWebCrawlers"`
	ImageProxyEnabled           bool                     `json:"imageProxyEnabled"`
	KeepStatusDays              int32                    `json:"keepStatusDays"`
	MaxEntriesAgeDays           int32                    `json:"maxEntriesAgeDays"`
	MaxFeedCapacity             int32                    `json:"maxFeedCapacity"`
	MaxFeedsPerUser             int32                    `json:"maxFeedsPerUser"`
	PublicUrl                   string                   `json:"publicUrl"`
	QueryTimeout                int32                    `json:"queryTimeout"`
	RefreshIntervalMinutes      int32                    `json:"refreshIntervalMinutes"`
	SmtpFromAddress             *string                  `json:"smtpFromAddress,omitempty"`
	SmtpHost                    *string                  `json:"smtpHost,omitempty"`
	SmtpPassword                *string                  `json:"smtpPassword,omitempty"`
	SmtpPort                    *int32                   `json:"smtpPort,omitempty"`
	SmtpTls                     *bool                    `json:"smtpTls,omitempty"`
	SmtpUserName                *string                  `json:"smtpUserName,omitempty"`
	StrictPasswordPolicy        bool                     `json:"strictPasswordPolicy"`
	TreeReloadInterval          *string                  `json:"treeReloadInterval,omitempty"`
	UnreadThreshold             *time.Time               `json:"unreadThreshold,omitempty"`
	UserAgent                   *string                  `json:"userAgent,omitempty"`
	WebsocketEnabled            *bool                    `json:"websocketEnabled,omitempty"`
	WebsocketPingInterval       *string                  `json:"websocketPingInterval,omitempty"`
}

// ApplicationSettingsCache defines model for ApplicationSettings.Cache.
type ApplicationSettingsCache string

// Category Entry details
type Category struct {
	// Children category children categories
	Children []Category `json:"children"`

	// Expanded whether the category is expanded or collapsed
	Expanded bool `json:"expanded"`

	// Feeds category feeds
	Feeds []Subscription `json:"feeds"`

	// Id category id
	Id string `json:"id"`

	// Name category id
	Name string `json:"name"`

	// ParentId parent category id
	ParentId *string `json:"parentId,omitempty"`

	// ParentName parent category name
	ParentName *string `json:"parentName,omitempty"`

	// Position position of the category in the list
	Position int32 `json:"position"`
}

// CategoryModificationRequest Category modification request
type CategoryModificationRequest struct {
	// Id id
	Id int64 `json:"id"`

	// Name new name, null if not changed
	Name *string `json:"name,omitempty"`

	// ParentId new parent category id
	ParentId *string `json:"parentId,omitempty"`

	// Position new display position, null if not changed
	Position *int32 `json:"position,omitempty"`
}

// CollapseRequest Mark Request
type CollapseRequest struct {
	// Collapse collapse
	Collapse bool `json:"collapse"`

	// Id category id
	Id int64 `json:"id"`
}

// Entries List of entries with some metadata
type Entries struct {
	// Entries list of entries
	Entries []Entry `json:"entries"`

	// ErrorCount times the server tried to refresh the feed and failed
	ErrorCount int32 `json:"errorCount"`

	// FeedLink URL of the website, extracted from the feed, only filled if querying for feed entries, not category entries
	FeedLink *string `json:"feedLink,omitempty"`

	// HasMore if the query has more elements
	HasMore bool `json:"hasMore"`

	// IgnoredReadStatus if true, the unread flag was ignored in the request, all entries are returned regardless of their read status
	IgnoredReadStatus bool `json:"ignoredReadStatus"`

	// Limit the requested limit
	Limit *int32 `json:"limit,omitempty"`

	// Message error or warning message
	Message *string `json:"message,omitempty"`

	// Name name of the feed or the category requested
	Name string `json:"name"`

	// Offset the requested offset
	Offset *int32 `json:"offset,omitempty"`

	// Timestamp list generation timestamp
	Timestamp int64 `json:"timestamp"`
}

// Entry Entry details
type Entry struct {
	// Author entry author
	Author *string `json:"author,omitempty"`

	// Categories comma-separated list of categories
	Categories *string `json:"categories,omitempty"`

	// Content entry content
	Content string `json:"content"`

	// Date entry publication date
	Date float32 `json:"date"`

	// EnclosureType entry enclosure mime type, if any
	EnclosureType *string `json:"enclosureType,omitempty"`

	// EnclosureUrl entry enclosure url, if any
	EnclosureUrl *string `json:"enclosureUrl,omitempty"`

	// FeedId feed id
	FeedId string `json:"feedId"`

	// FeedLink this entry's website url
	FeedLink string `json:"feedLink"`

	// FeedName feed name
	FeedName string `json:"feedName"`

	// FeedUrl this entry's feed url
	FeedUrl string `json:"feedUrl"`

	// Guid entry guid
	Guid string `json:"guid"`

	// IconUrl The favicon url to use for this feed
	IconUrl string `json:"iconUrl"`

	// Id entry id
	Id string `json:"id"`

	// InsertedDate entry insertion date in the database
	InsertedDate float32 `json:"insertedDate"`

	// Markable whether the entry is still markable (old entry statuses are discarded)
	Markable bool `json:"markable"`

	// MediaDescription entry media description, if any
	MediaDescription *string `json:"mediaDescription,omitempty"`

	// MediaThumbnailHeight entry media thumbnail height, if any
	MediaThumbnailHeight *int32 `json:"mediaThumbnailHeight,omitempty"`

	// MediaThumbnailUrl entry media thumbnail url, if any
	MediaThumbnailUrl *string `json:"mediaThumbnailUrl,omitempty"`

	// MediaThumbnailWidth entry media thumbnail width, if any
	MediaThumbnailWidth *int32 `json:"mediaThumbnailWidth,omitempty"`

	// Read read status
	Read bool `json:"read"`

	// Rtl whether entry content and title are rtl
	Rtl bool `json:"rtl"`

	// Starred starred status
	Starred bool `json:"starred"`

	// Tags tags
	Tags []string `json:"tags"`

	// Title entry title
	Title string `json:"title"`

	// Url entry url
	Url string `json:"url"`
}

// FeedInfo Feed details
type FeedInfo struct {
	// Title title
	Title string `json:"title"`

	// Url url
	Url string `json:"url"`
}

// FeedInfoRequest Feed information request
type FeedInfoRequest struct {
	// Url feed url
	Url string `json:"url"`
}

// FeedModificationRequest Feed modification request
type FeedModificationRequest struct {
	// CategoryId new parent category id
	CategoryId *string `json:"categoryId,omitempty"`

	// Filter JEXL string evaluated on new entries to mark them as read if they do not match
	Filter *string `json:"filter,omitempty"`

	// Id id
	Id int64 `json:"id"`

	// Name new name, null if not changed
	Name *string `json:"name,omitempty"`

	// Position new display position, null if not changed
	Position *int32 `json:"position,omitempty"`
}

// IDRequest defines model for IDRequest.
type IDRequest struct {
	Id int64 `json:"id"`
}

// LoginRequest defines model for LoginRequest.
type LoginRequest struct {
	// Name username
	Name string `json:"name"`

	// Password password
	Password string `json:"password"`
}

// MarkRequest Mark Request
type MarkRequest struct {
	// ExcludedSubscriptions if marking a category or 'all', exclude those subscriptions from the marking
	ExcludedSubscriptions *[]int64 `json:"excludedSubscriptions,omitempty"`

	// Id entry id, category id, 'all' or 'starred'
	Id string `json:"id"`

	// InsertedBefore pass the timestamp you got from the entry list to avoid marking entries that may have been fetched in the mean time and never displayed
	InsertedBefore *int64 `json:"insertedBefore,omitempty"`

	// Keywords only mark read if a feed has these keywords in the title or rss content
	Keywords *string `json:"keywords,omitempty"`

	// OlderThan mark only entries older than this
	OlderThan *int64 `json:"olderThan,omitempty"`

	// Read mark as read or unread
	Read bool `json:"read"`
}

// MultipleMarkRequest Multiple Mark Request
type MultipleMarkRequest struct {
	// Requests list of mark requests
	Requests []MarkRequest `json:"requests"`
}

// PasswordResetRequest defines model for PasswordResetRequest.
type PasswordResetRequest struct {
	// Email email address for password recovery
	Email string `json:"email"`
}

// ProfileModificationRequest Profile modification request
type ProfileModificationRequest struct {
	// CurrentPassword current user password, required to change profile data
	CurrentPassword string `json:"currentPassword"`

	// Email changes email of the user, if specified
	Email *string `json:"email,omitempty"`

	// NewApiKey generate a new api key
	NewApiKey *bool `json:"newApiKey,omitempty"`

	// NewPassword changes password of the user, if specified
	NewPassword *string `json:"newPassword,omitempty"`
}

// RegistrationRequest defines model for RegistrationRequest.
type RegistrationRequest struct {
	// Email email address for password recovery
	Email string `json:"email"`

	// Name username, between 3 and 32 characters
	Name string `json:"name"`

	// Password password, minimum 6 characters
	Password string `json:"password"`
}

// ServerInfo Server infos
type ServerInfo struct {
	AllowRegistrations    bool    `json:"allowRegistrations"`
	Announcement          *string `json:"announcement,omitempty"`
	DemoAccountEnabled    bool    `json:"demoAccountEnabled"`
	GitCommit             string  `json:"gitCommit"`
	GoogleAnalyticsCode   *string `json:"googleAnalyticsCode,omitempty"`
	SmtpEnabled           bool    `json:"smtpEnabled"`
	TreeReloadInterval    int64   `json:"treeReloadInterval"`
	Version               string  `json:"version"`
	WebsocketEnabled      bool    `json:"websocketEnabled"`
	WebsocketPingInterval int64   `json:"websocketPingInterval"`
}

// Settings User settings
type Settings struct {
	// CustomContextMenu show commafeed's own context menu on right click
	CustomContextMenu bool `json:"customContextMenu"`

	// CustomCss user's custom css for the website
	CustomCss *string `json:"customCss,omitempty"`

	// CustomJs user's custom js for the website
	CustomJs *string `json:"customJs,omitempty"`

	// ExternalLinkIconDisplayMode whether to show the external link icon in the header of entries
	ExternalLinkIconDisplayMode SettingsExternalLinkIconDisplayMode `json:"externalLinkIconDisplayMode"`

	// Language user's preferred language, english if none
	Language string `json:"language"`

	// MarkAllAsReadConfirmation ask for confirmation when marking all entries as read
	MarkAllAsReadConfirmation bool `json:"markAllAsReadConfirmation"`

	// MobileFooter on mobile, show action buttons at the bottom of the screen
	MobileFooter bool `json:"mobileFooter"`

	// ReadingMode user reads all entries or unread entries only
	ReadingMode SettingsReadingMode `json:"readingMode"`

	// ReadingOrder user reads entries in ascending or descending order
	ReadingOrder SettingsReadingOrder `json:"readingOrder"`

	// ScrollMarks In expanded view, scroll through entries mark them as read
	ScrollMarks bool `json:"scrollMarks"`

	// ScrollMode whether to scroll to the selected entry
	ScrollMode SettingsScrollMode `json:"scrollMode"`

	// ScrollSpeed user's preferred scroll speed when navigating between entries
	ScrollSpeed int32 `json:"scrollSpeed"`

	// SharingSettings User sharing settings
	SharingSettings SharingSettings `json:"sharingSettings"`

	// ShowRead user wants category and feeds with no unread entries shown
	ShowRead bool `json:"showRead"`

	// StarIconDisplayMode whether to show the star icon in the header of entries
	StarIconDisplayMode SettingsStarIconDisplayMode `json:"starIconDisplayMode"`
}

// SettingsExternalLinkIconDisplayMode whether to show the external link icon in the header of entries
type SettingsExternalLinkIconDisplayMode string

// SettingsReadingMode user reads all entries or unread entries only
type SettingsReadingMode string

// SettingsReadingOrder user reads entries in ascending or descending order
type SettingsReadingOrder string

// SettingsScrollMode whether to scroll to the selected entry
type SettingsScrollMode string

// SettingsStarIconDisplayMode whether to show the star icon in the header of entries
type SettingsStarIconDisplayMode string

// SharingSettings User sharing settings
type SharingSettings struct {
	Buffer     bool `json:"buffer"`
	Email      bool `json:"email"`
	Facebook   bool `json:"facebook"`
	Gmail      bool `json:"gmail"`
	Instapaper bool `json:"instapaper"`
	Pocket     bool `json:"pocket"`
	Tumblr     bool `json:"tumblr"`
	Twitter    bool `json:"twitter"`
}

// StarRequest Star Request
type StarRequest struct {
	// FeedId feed id
	FeedId int64 `json:"feedId"`

	// Id id
	Id string `json:"id"`

	// Starred starred or not
	Starred bool `json:"starred"`
}

// SubscribeRequest Subscription request
type SubscribeRequest struct {
	// CategoryId id of the user category to place the feed in
	CategoryId *string `json:"categoryId,omitempty"`

	// Title name of the feed for the user
	Title string `json:"title"`

	// Url url of the feed
	Url string `json:"url"`
}

// Subscription User information
type Subscription struct {
	// CategoryId category id
	CategoryId *string `json:"categoryId,omitempty"`

	// ErrorCount error count
	ErrorCount int32 `json:"errorCount"`

	// FeedLink this subscription's website url
	FeedLink string `json:"feedLink"`

	// FeedUrl this subscription's feed url
	FeedUrl string `json:"feedUrl"`

	// Filter JEXL string evaluated on new entries to mark them as read if they do not match
	Filter *string `json:"filter,omitempty"`

	// IconUrl The favicon url to use for this feed
	IconUrl string `json:"iconUrl"`

	// Id subscription id
	Id int64 `json:"id"`

	// LastRefresh last time the feed was refreshed
	LastRefresh *float32 `json:"lastRefresh,omitempty"`

	// Message error message while fetching the feed
	Message *string `json:"message,omitempty"`

	// Name subscription name
	Name string `json:"name"`

	// NewestItemTime date of the newest item
	NewestItemTime *float32 `json:"newestItemTime,omitempty"`

	// NextRefresh next time the feed refresh is planned, null if refresh is already queued
	NextRefresh *float32 `json:"nextRefresh,omitempty"`

	// Position position of the subscription's in the list
	Position *int32 `json:"position,omitempty"`

	// Unread unread count
	Unread int64 `json:"unread"`
}

// TagRequest Tag Request
type TagRequest struct {
	// EntryId entry id
	EntryId int64 `json:"entryId"`

	// Tags tags
	Tags []string `json:"tags"`
}

// UnreadCount Unread count
type UnreadCount struct {
	FeedId         *int64   `json:"feedId,omitempty"`
	NewestItemTime *float32 `json:"newestItemTime,omitempty"`
	UnreadCount    *int64   `json:"unreadCount,omitempty"`
}

// UserModel User information
type UserModel struct {
	// Admin user is admin
	Admin bool `json:"admin"`

	// ApiKey api key
	ApiKey *string `json:"apiKey,omitempty"`

	// Created account creation date
	Created *float32 `json:"created,omitempty"`

	// Email user email, if any
	Email *string `json:"email,omitempty"`

	// Enabled account status
	Enabled bool `json:"enabled"`

	// Id user id
	Id int64 `json:"id"`

	// LastLogin last login date
	LastLogin *float32 `json:"lastLogin,omitempty"`

	// Name user name
	Name string `json:"name"`

	// Password user password, never returned by the api
	Password *string `json:"password,omitempty"`
}

// GetCategoryEntriesParams defines parameters for GetCategoryEntries.
type GetCategoryEntriesParams struct {
	// Id id of the category, 'all' or 'starred'
	Id string `form:"id" json:"id"`

	// ReadType all entries or only unread ones
	ReadType GetCategoryEntriesParamsReadType `form:"readType" json:"readType"`

	// NewerThan only entries newer than this
	NewerThan *int64 `form:"newerThan,omitempty" json:"newerThan,omitempty"`

	// Offset offset for paging
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit limit for paging, default 20, maximum 1000
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order ordering
	Order *GetCategoryEntriesParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Keywords search for keywords in either the title or the content of the entries, separated by spaces, 3 characters minimum
	Keywords *string `form:"keywords,omitempty" json:"keywords,omitempty"`

	// OnlyIds return only entry ids
	OnlyIds *bool `form:"onlyIds,omitempty" json:"onlyIds,omitempty"`

	// ExcludedSubscriptionIds comma-separated list of excluded subscription ids
	ExcludedSubscriptionIds *string `form:"excludedSubscriptionIds,omitempty" json:"excludedSubscriptionIds,omitempty"`

	// Tag keep only entries tagged with this tag
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`
}

// GetCategoryEntriesParamsReadType defines parameters for GetCategoryEntries.
type GetCategoryEntriesParamsReadType string

// GetCategoryEntriesParamsOrder defines parameters for GetCategoryEntries.
type GetCategoryEntriesParamsOrder string

// GetCategoryEntriesAsFeedParams defines parameters for GetCategoryEntriesAsFeed.
type GetCategoryEntriesAsFeedParams struct {
	// Id id of the category, 'all' or 'starred'
	Id string `form:"id" json:"id"`

	// ReadType all entries or only unread ones
	ReadType GetCategoryEntriesAsFeedParamsReadType `form:"readType" json:"readType"`

	// NewerThan only entries newer than this
	NewerThan *int64 `form:"newerThan,omitempty" json:"newerThan,omitempty"`

	// Offset offset for paging
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit limit for paging, default 20, maximum 1000
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order date ordering
	Order *GetCategoryEntriesAsFeedParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Keywords search for keywords in either the title or the content of the entries, separated by spaces, 3 characters minimum
	Keywords *string `form:"keywords,omitempty" json:"keywords,omitempty"`

	// OnlyIds return only entry ids
	OnlyIds *bool `form:"onlyIds,omitempty" json:"onlyIds,omitempty"`

	// ExcludedSubscriptionIds comma-separated list of excluded subscription ids
	ExcludedSubscriptionIds *string `form:"excludedSubscriptionIds,omitempty" json:"excludedSubscriptionIds,omitempty"`

	// Tag keep only entries tagged with this tag
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`
}

// GetCategoryEntriesAsFeedParamsReadType defines parameters for GetCategoryEntriesAsFeed.
type GetCategoryEntriesAsFeedParamsReadType string

// GetCategoryEntriesAsFeedParamsOrder defines parameters for GetCategoryEntriesAsFeed.
type GetCategoryEntriesAsFeedParamsOrder string

// GetFeedEntriesParams defines parameters for GetFeedEntries.
type GetFeedEntriesParams struct {
	// Id id of the feed
	Id string `form:"id" json:"id"`

	// ReadType all entries or only unread ones
	ReadType GetFeedEntriesParamsReadType `form:"readType" json:"readType"`

	// NewerThan only entries newer than this
	NewerThan *int64 `form:"newerThan,omitempty" json:"newerThan,omitempty"`

	// Offset offset for paging
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit limit for paging, default 20, maximum 1000
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order ordering
	Order *GetFeedEntriesParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Keywords search for keywords in either the title or the content of the entries, separated by spaces, 3 characters minimum
	Keywords *string `form:"keywords,omitempty" json:"keywords,omitempty"`

	// OnlyIds return only entry ids
	OnlyIds *bool `form:"onlyIds,omitempty" json:"onlyIds,omitempty"`
}

// GetFeedEntriesParamsReadType defines parameters for GetFeedEntries.
type GetFeedEntriesParamsReadType string

// GetFeedEntriesParamsOrder defines parameters for GetFeedEntries.
type GetFeedEntriesParamsOrder string

// GetFeedEntriesAsFeedParams defines parameters for GetFeedEntriesAsFeed.
type GetFeedEntriesAsFeedParams struct {
	// Id id of the feed
	Id string `form:"id" json:"id"`

	// ReadType all entries or only unread ones
	ReadType GetFeedEntriesAsFeedParamsReadType `form:"readType" json:"readType"`

	// NewerThan only entries newer than this
	NewerThan *int64 `form:"newerThan,omitempty" json:"newerThan,omitempty"`

	// Offset offset for paging
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit limit for paging, default 20, maximum 1000
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order date ordering
	Order *GetFeedEntriesAsFeedParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Keywords search for keywords in either the title or the content of the entries, separated by spaces, 3 characters minimum
	Keywords *string `form:"keywords,omitempty" json:"keywords,omitempty"`

	// OnlyIds return only entry ids
	OnlyIds *bool `form:"onlyIds,omitempty" json:"onlyIds,omitempty"`
}

// GetFeedEntriesAsFeedParamsReadType defines parameters for GetFeedEntriesAsFeed.
type GetFeedEntriesAsFeedParamsReadType string

// GetFeedEntriesAsFeedParamsOrder defines parameters for GetFeedEntriesAsFeed.
type GetFeedEntriesAsFeedParamsOrder string

// ImportOpmlMultipartBody defines parameters for ImportOpml.
type ImportOpmlMultipartBody struct {
	// File ompl file
	File map[string]interface{} `json:"file"`
}

// SubscribeFromUrlParams defines parameters for SubscribeFromUrl.
type SubscribeFromUrlParams struct {
	// Url feed url
	Url string `form:"url" json:"url"`
}

// GetProxiedImageParams defines parameters for GetProxiedImage.
type GetProxiedImageParams struct {
	// U image url
	U string `form:"u" json:"u"`
}

// PasswordRecoveryCallbackParams defines parameters for PasswordRecoveryCallback.
type PasswordRecoveryCallbackParams struct {
	Email string `form:"email" json:"email"`
	Token string `form:"token" json:"token"`
}

// AdminDeleteUserJSONRequestBody defines body for AdminDeleteUser for application/json ContentType.
type AdminDeleteUserJSONRequestBody = IDRequest

// AdminSaveUserJSONRequestBody defines body for AdminSaveUser for application/json ContentType.
type AdminSaveUserJSONRequestBody = AdminSaveUserRequest

// AddCategoryJSONRequestBody defines body for AddCategory for application/json ContentType.
type AddCategoryJSONRequestBody = AddCategoryRequest

// CollapseCategoryJSONRequestBody defines body for CollapseCategory for application/json ContentType.
type CollapseCategoryJSONRequestBody = CollapseRequest

// DeleteCategoryJSONRequestBody defines body for DeleteCategory for application/json ContentType.
type DeleteCategoryJSONRequestBody = IDRequest

// MarkCategoryEntriesJSONRequestBody defines body for MarkCategoryEntries for application/json ContentType.
type MarkCategoryEntriesJSONRequestBody = MarkRequest

// ModifyCategoryJSONRequestBody defines body for ModifyCategory for application/json ContentType.
type ModifyCategoryJSONRequestBody = CategoryModificationRequest

// MarkEntryJSONRequestBody defines body for MarkEntry for application/json ContentType.
type MarkEntryJSONRequestBody = MarkRequest

// MarkEntriesJSONRequestBody defines body for MarkEntries for application/json ContentType.
type MarkEntriesJSONRequestBody = MultipleMarkRequest

// StarEntryJSONRequestBody defines body for StarEntry for application/json ContentType.
type StarEntryJSONRequestBody = StarRequest

// TagEntryJSONRequestBody defines body for TagEntry for application/json ContentType.
type TagEntryJSONRequestBody = TagRequest

// FetchFeedJSONRequestBody defines body for FetchFeed for application/json ContentType.
type FetchFeedJSONRequestBody = FeedInfoRequest

// ImportOpmlMultipartRequestBody defines body for ImportOpml for multipart/form-data ContentType.
type ImportOpmlMultipartRequestBody ImportOpmlMultipartBody

// MarkFeedEntriesJSONRequestBody defines body for MarkFeedEntries for application/json ContentType.
type MarkFeedEntriesJSONRequestBody = MarkRequest

// ModifyFeedJSONRequestBody defines body for ModifyFeed for application/json ContentType.
type ModifyFeedJSONRequestBody = FeedModificationRequest

// QueueForRefreshJSONRequestBody defines body for QueueForRefresh for application/json ContentType.
type QueueForRefreshJSONRequestBody = IDRequest

// SubscribeJSONRequestBody defines body for Subscribe for application/json ContentType.
type SubscribeJSONRequestBody = SubscribeRequest

// UnsubscribeJSONRequestBody defines body for Unsubscribe for application/json ContentType.
type UnsubscribeJSONRequestBody = IDRequest

// LoginJSONRequestBody defines body for Login for application/json ContentType.
type LoginJSONRequestBody = LoginRequest

// SendPasswordResetJSONRequestBody defines body for SendPasswordReset for application/json ContentType.
type SendPasswordResetJSONRequestBody = PasswordResetRequest

// SaveUserProfileJSONRequestBody defines body for SaveUserProfile for application/json ContentType.
type SaveUserProfileJSONRequestBody = ProfileModificationRequest

// RegisterUserJSONRequestBody defines body for RegisterUser for application/json ContentType.
type RegisterUserJSONRequestBody = RegistrationRequest

// SaveUserSettingsJSONRequestBody defines body for SaveUserSettings for application/json ContentType.
type SaveUserSettingsJSONRequestBody = Settings

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetMetrics request
	GetMetrics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApplicationSettings request
	GetApplicationSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AdminDeleteUserWithBody request with any body
	AdminDeleteUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AdminDeleteUser(ctx context.Context, body AdminDeleteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AdminGetUser request
	AdminGetUser(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AdminGetUsers request
	AdminGetUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AdminSaveUserWithBody request with any body
	AdminSaveUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AdminSaveUser(ctx context.Context, body AdminSaveUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddCategoryWithBody request with any body
	AddCategoryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddCategory(ctx context.Context, body AddCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CollapseCategoryWithBody request with any body
	CollapseCategoryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CollapseCategory(ctx context.Context, body CollapseCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCategoryWithBody request with any body
	DeleteCategoryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteCategory(ctx context.Context, body DeleteCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCategoryEntries request
	GetCategoryEntries(ctx context.Context, params *GetCategoryEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCategoryEntriesAsFeed request
	GetCategoryEntriesAsFeed(ctx context.Context, params *GetCategoryEntriesAsFeedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRootCategory request
	GetRootCategory(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MarkCategoryEntriesWithBody request with any body
	MarkCategoryEntriesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MarkCategoryEntries(ctx context.Context, body MarkCategoryEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModifyCategoryWithBody request with any body
	ModifyCategoryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ModifyCategory(ctx context.Context, body ModifyCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUnreadCount request
	GetUnreadCount(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MarkEntryWithBody request with any body
	MarkEntryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MarkEntry(ctx context.Context, body MarkEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MarkEntriesWithBody request with any body
	MarkEntriesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MarkEntries(ctx context.Context, body MarkEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StarEntryWithBody request with any body
	StarEntryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StarEntry(ctx context.Context, body StarEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TagEntryWithBody request with any body
	TagEntryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TagEntry(ctx context.Context, body TagEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTags request
	GetTags(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFeedEntries request
	GetFeedEntries(ctx context.Context, params *GetFeedEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFeedEntriesAsFeed request
	GetFeedEntriesAsFeed(ctx context.Context, params *GetFeedEntriesAsFeedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportOpml request
	ExportOpml(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFeedFavicon request
	GetFeedFavicon(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FetchFeedWithBody request with any body
	FetchFeedWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FetchFeed(ctx context.Context, body FetchFeedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFeed request
	GetFeed(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportOpmlWithBody request with any body
	ImportOpmlWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MarkFeedEntriesWithBody request with any body
	MarkFeedEntriesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MarkFeedEntries(ctx context.Context, body MarkFeedEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModifyFeedWithBody request with any body
	ModifyFeedWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ModifyFeed(ctx context.Context, body ModifyFeedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QueueForRefreshWithBody request with any body
	QueueForRefreshWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	QueueForRefresh(ctx context.Context, body QueueForRefreshJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QueueAllForRefresh request
	QueueAllForRefresh(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SubscribeFromUrl request
	SubscribeFromUrl(ctx context.Context, params *SubscribeFromUrlParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SubscribeWithBody request with any body
	SubscribeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Subscribe(ctx context.Context, body SubscribeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnsubscribeWithBody request with any body
	UnsubscribeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Unsubscribe(ctx context.Context, body UnsubscribeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServerInfos request
	GetServerInfos(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProxiedImage request
	GetProxiedImage(ctx context.Context, params *GetProxiedImageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoginWithBody request with any body
	LoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Login(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendPasswordResetWithBody request with any body
	SendPasswordResetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendPasswordReset(ctx context.Context, body SendPasswordResetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasswordRecoveryCallback request
	PasswordRecoveryCallback(ctx context.Context, params *PasswordRecoveryCallbackParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserProfile request
	GetUserProfile(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SaveUserProfileWithBody request with any body
	SaveUserProfileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SaveUserProfile(ctx context.Context, body SaveUserProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegisterUserWithBody request with any body
	RegisterUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RegisterUser(ctx context.Context, body RegisterUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserSettings request
	GetUserSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SaveUserSettingsWithBody request with any body
	SaveUserSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SaveUserSettings(ctx context.Context, body SaveUserSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetMetrics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMetricsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApplicationSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApplicationSettingsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AdminDeleteUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAdminDeleteUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AdminDeleteUser(ctx context.Context, body AdminDeleteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAdminDeleteUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AdminGetUser(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAdminGetUserRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AdminGetUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAdminGetUsersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AdminSaveUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAdminSaveUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AdminSaveUser(ctx context.Context, body AdminSaveUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAdminSaveUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddCategoryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddCategoryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddCategory(ctx context.Context, body AddCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddCategoryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CollapseCategoryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCollapseCategoryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CollapseCategory(ctx context.Context, body CollapseCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCollapseCategoryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCategoryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCategoryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCategory(ctx context.Context, body DeleteCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCategoryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCategoryEntries(ctx context.Context, params *GetCategoryEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCategoryEntriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCategoryEntriesAsFeed(ctx context.Context, params *GetCategoryEntriesAsFeedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCategoryEntriesAsFeedRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRootCategory(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRootCategoryRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkCategoryEntriesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkCategoryEntriesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkCategoryEntries(ctx context.Context, body MarkCategoryEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkCategoryEntriesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyCategoryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyCategoryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyCategory(ctx context.Context, body ModifyCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyCategoryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUnreadCount(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUnreadCountRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkEntryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkEntryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkEntry(ctx context.Context, body MarkEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkEntryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkEntriesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkEntriesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkEntries(ctx context.Context, body MarkEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkEntriesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StarEntryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStarEntryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StarEntry(ctx context.Context, body StarEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStarEntryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TagEntryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagEntryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TagEntry(ctx context.Context, body TagEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagEntryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTags(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTagsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFeedEntries(ctx context.Context, params *GetFeedEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFeedEntriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFeedEntriesAsFeed(ctx context.Context, params *GetFeedEntriesAsFeedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFeedEntriesAsFeedRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportOpml(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportOpmlRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFeedFavicon(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFeedFaviconRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FetchFeedWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFetchFeedRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FetchFeed(ctx context.Context, body FetchFeedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFetchFeedRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFeed(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFeedRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportOpmlWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportOpmlRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkFeedEntriesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkFeedEntriesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkFeedEntries(ctx context.Context, body MarkFeedEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkFeedEntriesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyFeedWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyFeedRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyFeed(ctx context.Context, body ModifyFeedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyFeedRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueueForRefreshWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueueForRefreshRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueueForRefresh(ctx context.Context, body QueueForRefreshJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueueForRefreshRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueueAllForRefresh(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueueAllForRefreshRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubscribeFromUrl(ctx context.Context, params *SubscribeFromUrlParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubscribeFromUrlRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubscribeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubscribeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Subscribe(ctx context.Context, body SubscribeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubscribeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnsubscribeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnsubscribeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Unsubscribe(ctx context.Context, body UnsubscribeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnsubscribeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServerInfos(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServerInfosRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProxiedImage(ctx context.Context, params *GetProxiedImageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProxiedImageRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Login(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendPasswordResetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendPasswordResetRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendPasswordReset(ctx context.Context, body SendPasswordResetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendPasswordResetRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasswordRecoveryCallback(ctx context.Context, params *PasswordRecoveryCallbackParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasswordRecoveryCallbackRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserProfile(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserProfileRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveUserProfileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveUserProfileRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveUserProfile(ctx context.Context, body SaveUserProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveUserProfileRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterUser(ctx context.Context, body RegisterUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserSettingsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveUserSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveUserSettingsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveUserSettings(ctx context.Context, body SaveUserSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveUserSettingsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetMetricsRequest generates requests for GetMetrics
func NewGetMetricsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetApplicationSettingsRequest generates requests for GetApplicationSettings
func NewGetApplicationSettingsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAdminDeleteUserRequest calls the generic AdminDeleteUser builder with application/json body
func NewAdminDeleteUserRequest(server string, body AdminDeleteUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAdminDeleteUserRequestWithBody(server, "application/json", bodyReader)
}

// NewAdminDeleteUserRequestWithBody generates requests for AdminDeleteUser with any type of body
func NewAdminDeleteUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/user/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAdminGetUserRequest generates requests for AdminGetUser
func NewAdminGetUserRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/user/get/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAdminGetUsersRequest generates requests for AdminGetUsers
func NewAdminGetUsersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/user/getAll")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAdminSaveUserRequest calls the generic AdminSaveUser builder with application/json body
func NewAdminSaveUserRequest(server string, body AdminSaveUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAdminSaveUserRequestWithBody(server, "application/json", bodyReader)
}

// NewAdminSaveUserRequestWithBody generates requests for AdminSaveUser with any type of body
func NewAdminSaveUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/user/save")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddCategoryRequest calls the generic AddCategory builder with application/json body
func NewAddCategoryRequest(server string, body AddCategoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddCategoryRequestWithBody(server, "application/json", bodyReader)
}

// NewAddCategoryRequestWithBody generates requests for AddCategory with any type of body
func NewAddCategoryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/category/add")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCollapseCategoryRequest calls the generic CollapseCategory builder with application/json body
func NewCollapseCategoryRequest(server string, body CollapseCategoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCollapseCategoryRequestWithBody(server, "application/json", bodyReader)
}

// NewCollapseCategoryRequestWithBody generates requests for CollapseCategory with any type of body
func NewCollapseCategoryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/category/collapse")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCategoryRequest calls the generic DeleteCategory builder with application/json body
func NewDeleteCategoryRequest(server string, body DeleteCategoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteCategoryRequestWithBody(server, "application/json", bodyReader)
}

// NewDeleteCategoryRequestWithBody generates requests for DeleteCategory with any type of body
func NewDeleteCategoryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/category/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCategoryEntriesRequest generates requests for GetCategoryEntries
func NewGetCategoryEntriesRequest(server string, params *GetCategoryEntriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/category/entries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "readType", runtime.ParamLocationQuery, params.ReadType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.NewerThan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newerThan", runtime.ParamLocationQuery, *params.NewerThan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Keywords != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keywords", runtime.ParamLocationQuery, *params.Keywords); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "onlyIds", runtime.ParamLocationQuery, *params.OnlyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludedSubscriptionIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludedSubscriptionIds", runtime.ParamLocationQuery, *params.ExcludedSubscriptionIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCategoryEntriesAsFeedRequest generates requests for GetCategoryEntriesAsFeed
func NewGetCategoryEntriesAsFeedRequest(server string, params *GetCategoryEntriesAsFeedParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/category/entriesAsFeed")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "readType", runtime.ParamLocationQuery, params.ReadType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.NewerThan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newerThan", runtime.ParamLocationQuery, *params.NewerThan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Keywords != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keywords", runtime.ParamLocationQuery, *params.Keywords); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "onlyIds", runtime.ParamLocationQuery, *params.OnlyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludedSubscriptionIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludedSubscriptionIds", runtime.ParamLocationQuery, *params.ExcludedSubscriptionIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRootCategoryRequest generates requests for GetRootCategory
func NewGetRootCategoryRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/category/get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMarkCategoryEntriesRequest calls the generic MarkCategoryEntries builder with application/json body
func NewMarkCategoryEntriesRequest(server string, body MarkCategoryEntriesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMarkCategoryEntriesRequestWithBody(server, "application/json", bodyReader)
}

// NewMarkCategoryEntriesRequestWithBody generates requests for MarkCategoryEntries with any type of body
func NewMarkCategoryEntriesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/category/mark")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewModifyCategoryRequest calls the generic ModifyCategory builder with application/json body
func NewModifyCategoryRequest(server string, body ModifyCategoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewModifyCategoryRequestWithBody(server, "application/json", bodyReader)
}

// NewModifyCategoryRequestWithBody generates requests for ModifyCategory with any type of body
func NewModifyCategoryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/category/modify")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUnreadCountRequest generates requests for GetUnreadCount
func NewGetUnreadCountRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/category/unreadCount")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMarkEntryRequest calls the generic MarkEntry builder with application/json body
func NewMarkEntryRequest(server string, body MarkEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMarkEntryRequestWithBody(server, "application/json", bodyReader)
}

// NewMarkEntryRequestWithBody generates requests for MarkEntry with any type of body
func NewMarkEntryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/entry/mark")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMarkEntriesRequest calls the generic MarkEntries builder with application/json body
func NewMarkEntriesRequest(server string, body MarkEntriesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMarkEntriesRequestWithBody(server, "application/json", bodyReader)
}

// NewMarkEntriesRequestWithBody generates requests for MarkEntries with any type of body
func NewMarkEntriesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/entry/markMultiple")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStarEntryRequest calls the generic StarEntry builder with application/json body
func NewStarEntryRequest(server string, body StarEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStarEntryRequestWithBody(server, "application/json", bodyReader)
}

// NewStarEntryRequestWithBody generates requests for StarEntry with any type of body
func NewStarEntryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/entry/star")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTagEntryRequest calls the generic TagEntry builder with application/json body
func NewTagEntryRequest(server string, body TagEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTagEntryRequestWithBody(server, "application/json", bodyReader)
}

// NewTagEntryRequestWithBody generates requests for TagEntry with any type of body
func NewTagEntryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/entry/tag")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTagsRequest generates requests for GetTags
func NewGetTagsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/entry/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFeedEntriesRequest generates requests for GetFeedEntries
func NewGetFeedEntriesRequest(server string, params *GetFeedEntriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/feed/entries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "readType", runtime.ParamLocationQuery, params.ReadType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.NewerThan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newerThan", runtime.ParamLocationQuery, *params.NewerThan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Keywords != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keywords", runtime.ParamLocationQuery, *params.Keywords); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "onlyIds", runtime.ParamLocationQuery, *params.OnlyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFeedEntriesAsFeedRequest generates requests for GetFeedEntriesAsFeed
func NewGetFeedEntriesAsFeedRequest(server string, params *GetFeedEntriesAsFeedParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/feed/entriesAsFeed")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "readType", runtime.ParamLocationQuery, params.ReadType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.NewerThan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newerThan", runtime.ParamLocationQuery, *params.NewerThan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Keywords != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keywords", runtime.ParamLocationQuery, *params.Keywords); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "onlyIds", runtime.ParamLocationQuery, *params.OnlyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExportOpmlRequest generates requests for ExportOpml
func NewExportOpmlRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/feed/export")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFeedFaviconRequest generates requests for GetFeedFavicon
func NewGetFeedFaviconRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/feed/favicon/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFetchFeedRequest calls the generic FetchFeed builder with application/json body
func NewFetchFeedRequest(server string, body FetchFeedJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFetchFeedRequestWithBody(server, "application/json", bodyReader)
}

// NewFetchFeedRequestWithBody generates requests for FetchFeed with any type of body
func NewFetchFeedRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/feed/fetch")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFeedRequest generates requests for GetFeed
func NewGetFeedRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/feed/get/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewImportOpmlRequestWithBody generates requests for ImportOpml with any type of body
func NewImportOpmlRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/feed/import")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMarkFeedEntriesRequest calls the generic MarkFeedEntries builder with application/json body
func NewMarkFeedEntriesRequest(server string, body MarkFeedEntriesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMarkFeedEntriesRequestWithBody(server, "application/json", bodyReader)
}

// NewMarkFeedEntriesRequestWithBody generates requests for MarkFeedEntries with any type of body
func NewMarkFeedEntriesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/feed/mark")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewModifyFeedRequest calls the generic ModifyFeed builder with application/json body
func NewModifyFeedRequest(server string, body ModifyFeedJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewModifyFeedRequestWithBody(server, "application/json", bodyReader)
}

// NewModifyFeedRequestWithBody generates requests for ModifyFeed with any type of body
func NewModifyFeedRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/feed/modify")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewQueueForRefreshRequest calls the generic QueueForRefresh builder with application/json body
func NewQueueForRefreshRequest(server string, body QueueForRefreshJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewQueueForRefreshRequestWithBody(server, "application/json", bodyReader)
}

// NewQueueForRefreshRequestWithBody generates requests for QueueForRefresh with any type of body
func NewQueueForRefreshRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/feed/refresh")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewQueueAllForRefreshRequest generates requests for QueueAllForRefresh
func NewQueueAllForRefreshRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/feed/refreshAll")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSubscribeFromUrlRequest generates requests for SubscribeFromUrl
func NewSubscribeFromUrlRequest(server string, params *SubscribeFromUrlParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/feed/subscribe")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "url", runtime.ParamLocationQuery, params.Url); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSubscribeRequest calls the generic Subscribe builder with application/json body
func NewSubscribeRequest(server string, body SubscribeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSubscribeRequestWithBody(server, "application/json", bodyReader)
}

// NewSubscribeRequestWithBody generates requests for Subscribe with any type of body
func NewSubscribeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/feed/subscribe")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnsubscribeRequest calls the generic Unsubscribe builder with application/json body
func NewUnsubscribeRequest(server string, body UnsubscribeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnsubscribeRequestWithBody(server, "application/json", bodyReader)
}

// NewUnsubscribeRequestWithBody generates requests for Unsubscribe with any type of body
func NewUnsubscribeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/feed/unsubscribe")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetServerInfosRequest generates requests for GetServerInfos
func NewGetServerInfosRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/server/get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProxiedImageRequest generates requests for GetProxiedImage
func NewGetProxiedImageRequest(server string, params *GetProxiedImageParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/server/proxy")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "u", runtime.ParamLocationQuery, params.U); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoginRequest calls the generic Login builder with application/json body
func NewLoginRequest(server string, body LoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoginRequestWithBody(server, "application/json", bodyReader)
}

// NewLoginRequestWithBody generates requests for Login with any type of body
func NewLoginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSendPasswordResetRequest calls the generic SendPasswordReset builder with application/json body
func NewSendPasswordResetRequest(server string, body SendPasswordResetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendPasswordResetRequestWithBody(server, "application/json", bodyReader)
}

// NewSendPasswordResetRequestWithBody generates requests for SendPasswordReset with any type of body
func NewSendPasswordResetRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/passwordReset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPasswordRecoveryCallbackRequest generates requests for PasswordRecoveryCallback
func NewPasswordRecoveryCallbackRequest(server string, params *PasswordRecoveryCallbackParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/passwordResetCallback")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "email", runtime.ParamLocationQuery, params.Email); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, params.Token); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserProfileRequest generates requests for GetUserProfile
func NewGetUserProfileRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/profile")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSaveUserProfileRequest calls the generic SaveUserProfile builder with application/json body
func NewSaveUserProfileRequest(server string, body SaveUserProfileJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSaveUserProfileRequestWithBody(server, "application/json", bodyReader)
}

// NewSaveUserProfileRequestWithBody generates requests for SaveUserProfile with any type of body
func NewSaveUserProfileRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/profile")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserRequest generates requests for DeleteUser
func NewDeleteUserRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/profile/deleteAccount")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRegisterUserRequest calls the generic RegisterUser builder with application/json body
func NewRegisterUserRequest(server string, body RegisterUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRegisterUserRequestWithBody(server, "application/json", bodyReader)
}

// NewRegisterUserRequestWithBody generates requests for RegisterUser with any type of body
func NewRegisterUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/register")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserSettingsRequest generates requests for GetUserSettings
func NewGetUserSettingsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSaveUserSettingsRequest calls the generic SaveUserSettings builder with application/json body
func NewSaveUserSettingsRequest(server string, body SaveUserSettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSaveUserSettingsRequestWithBody(server, "application/json", bodyReader)
}

// NewSaveUserSettingsRequestWithBody generates requests for SaveUserSettings with any type of body
func NewSaveUserSettingsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetMetricsWithResponse request
	GetMetricsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMetricsResponse, error)

	// GetApplicationSettingsWithResponse request
	GetApplicationSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetApplicationSettingsResponse, error)

	// AdminDeleteUserWithBodyWithResponse request with any body
	AdminDeleteUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AdminDeleteUserResponse, error)

	AdminDeleteUserWithResponse(ctx context.Context, body AdminDeleteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AdminDeleteUserResponse, error)

	// AdminGetUserWithResponse request
	AdminGetUserWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*AdminGetUserResponse, error)

	// AdminGetUsersWithResponse request
	AdminGetUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AdminGetUsersResponse, error)

	// AdminSaveUserWithBodyWithResponse request with any body
	AdminSaveUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AdminSaveUserResponse, error)

	AdminSaveUserWithResponse(ctx context.Context, body AdminSaveUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AdminSaveUserResponse, error)

	// AddCategoryWithBodyWithResponse request with any body
	AddCategoryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddCategoryResponse, error)

	AddCategoryWithResponse(ctx context.Context, body AddCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*AddCategoryResponse, error)

	// CollapseCategoryWithBodyWithResponse request with any body
	CollapseCategoryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CollapseCategoryResponse, error)

	CollapseCategoryWithResponse(ctx context.Context, body CollapseCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*CollapseCategoryResponse, error)

	// DeleteCategoryWithBodyWithResponse request with any body
	DeleteCategoryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteCategoryResponse, error)

	DeleteCategoryWithResponse(ctx context.Context, body DeleteCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteCategoryResponse, error)

	// GetCategoryEntriesWithResponse request
	GetCategoryEntriesWithResponse(ctx context.Context, params *GetCategoryEntriesParams, reqEditors ...RequestEditorFn) (*GetCategoryEntriesResponse, error)

	// GetCategoryEntriesAsFeedWithResponse request
	GetCategoryEntriesAsFeedWithResponse(ctx context.Context, params *GetCategoryEntriesAsFeedParams, reqEditors ...RequestEditorFn) (*GetCategoryEntriesAsFeedResponse, error)

	// GetRootCategoryWithResponse request
	GetRootCategoryWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRootCategoryResponse, error)

	// MarkCategoryEntriesWithBodyWithResponse request with any body
	MarkCategoryEntriesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarkCategoryEntriesResponse, error)

	MarkCategoryEntriesWithResponse(ctx context.Context, body MarkCategoryEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*MarkCategoryEntriesResponse, error)

	// ModifyCategoryWithBodyWithResponse request with any body
	ModifyCategoryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyCategoryResponse, error)

	ModifyCategoryWithResponse(ctx context.Context, body ModifyCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyCategoryResponse, error)

	// GetUnreadCountWithResponse request
	GetUnreadCountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUnreadCountResponse, error)

	// MarkEntryWithBodyWithResponse request with any body
	MarkEntryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarkEntryResponse, error)

	MarkEntryWithResponse(ctx context.Context, body MarkEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*MarkEntryResponse, error)

	// MarkEntriesWithBodyWithResponse request with any body
	MarkEntriesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarkEntriesResponse, error)

	MarkEntriesWithResponse(ctx context.Context, body MarkEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*MarkEntriesResponse, error)

	// StarEntryWithBodyWithResponse request with any body
	StarEntryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StarEntryResponse, error)

	StarEntryWithResponse(ctx context.Context, body StarEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*StarEntryResponse, error)

	// TagEntryWithBodyWithResponse request with any body
	TagEntryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TagEntryResponse, error)

	TagEntryWithResponse(ctx context.Context, body TagEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*TagEntryResponse, error)

	// GetTagsWithResponse request
	GetTagsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTagsResponse, error)

	// GetFeedEntriesWithResponse request
	GetFeedEntriesWithResponse(ctx context.Context, params *GetFeedEntriesParams, reqEditors ...RequestEditorFn) (*GetFeedEntriesResponse, error)

	// GetFeedEntriesAsFeedWithResponse request
	GetFeedEntriesAsFeedWithResponse(ctx context.Context, params *GetFeedEntriesAsFeedParams, reqEditors ...RequestEditorFn) (*GetFeedEntriesAsFeedResponse, error)

	// ExportOpmlWithResponse request
	ExportOpmlWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ExportOpmlResponse, error)

	// GetFeedFaviconWithResponse request
	GetFeedFaviconWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetFeedFaviconResponse, error)

	// FetchFeedWithBodyWithResponse request with any body
	FetchFeedWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FetchFeedResponse, error)

	FetchFeedWithResponse(ctx context.Context, body FetchFeedJSONRequestBody, reqEditors ...RequestEditorFn) (*FetchFeedResponse, error)

	// GetFeedWithResponse request
	GetFeedWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetFeedResponse, error)

	// ImportOpmlWithBodyWithResponse request with any body
	ImportOpmlWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportOpmlResponse, error)

	// MarkFeedEntriesWithBodyWithResponse request with any body
	MarkFeedEntriesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarkFeedEntriesResponse, error)

	MarkFeedEntriesWithResponse(ctx context.Context, body MarkFeedEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*MarkFeedEntriesResponse, error)

	// ModifyFeedWithBodyWithResponse request with any body
	ModifyFeedWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyFeedResponse, error)

	ModifyFeedWithResponse(ctx context.Context, body ModifyFeedJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyFeedResponse, error)

	// QueueForRefreshWithBodyWithResponse request with any body
	QueueForRefreshWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueueForRefreshResponse, error)

	QueueForRefreshWithResponse(ctx context.Context, body QueueForRefreshJSONRequestBody, reqEditors ...RequestEditorFn) (*QueueForRefreshResponse, error)

	// QueueAllForRefreshWithResponse request
	QueueAllForRefreshWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*QueueAllForRefreshResponse, error)

	// SubscribeFromUrlWithResponse request
	SubscribeFromUrlWithResponse(ctx context.Context, params *SubscribeFromUrlParams, reqEditors ...RequestEditorFn) (*SubscribeFromUrlResponse, error)

	// SubscribeWithBodyWithResponse request with any body
	SubscribeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubscribeResponse, error)

	SubscribeWithResponse(ctx context.Context, body SubscribeJSONRequestBody, reqEditors ...RequestEditorFn) (*SubscribeResponse, error)

	// UnsubscribeWithBodyWithResponse request with any body
	UnsubscribeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnsubscribeResponse, error)

	UnsubscribeWithResponse(ctx context.Context, body UnsubscribeJSONRequestBody, reqEditors ...RequestEditorFn) (*UnsubscribeResponse, error)

	// GetServerInfosWithResponse request
	GetServerInfosWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetServerInfosResponse, error)

	// GetProxiedImageWithResponse request
	GetProxiedImageWithResponse(ctx context.Context, params *GetProxiedImageParams, reqEditors ...RequestEditorFn) (*GetProxiedImageResponse, error)

	// LoginWithBodyWithResponse request with any body
	LoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	LoginWithResponse(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	// SendPasswordResetWithBodyWithResponse request with any body
	SendPasswordResetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendPasswordResetResponse, error)

	SendPasswordResetWithResponse(ctx context.Context, body SendPasswordResetJSONRequestBody, reqEditors ...RequestEditorFn) (*SendPasswordResetResponse, error)

	// PasswordRecoveryCallbackWithResponse request
	PasswordRecoveryCallbackWithResponse(ctx context.Context, params *PasswordRecoveryCallbackParams, reqEditors ...RequestEditorFn) (*PasswordRecoveryCallbackResponse, error)

	// GetUserProfileWithResponse request
	GetUserProfileWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserProfileResponse, error)

	// SaveUserProfileWithBodyWithResponse request with any body
	SaveUserProfileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveUserProfileResponse, error)

	SaveUserProfileWithResponse(ctx context.Context, body SaveUserProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*SaveUserProfileResponse, error)

	// DeleteUserWithResponse request
	DeleteUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error)

	// RegisterUserWithBodyWithResponse request with any body
	RegisterUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterUserResponse, error)

	RegisterUserWithResponse(ctx context.Context, body RegisterUserJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterUserResponse, error)

	// GetUserSettingsWithResponse request
	GetUserSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserSettingsResponse, error)

	// SaveUserSettingsWithBodyWithResponse request with any body
	SaveUserSettingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveUserSettingsResponse, error)

	SaveUserSettingsWithResponse(ctx context.Context, body SaveUserSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*SaveUserSettingsResponse, error)
}

type GetMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApplicationSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ApplicationSettings
}

// Status returns HTTPResponse.Status
func (r GetApplicationSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApplicationSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AdminDeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AdminDeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AdminDeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AdminGetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *UserModel
}

// Status returns HTTPResponse.Status
func (r AdminGetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AdminGetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AdminGetUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *[]UserModel
}

// Status returns HTTPResponse.Status
func (r AdminGetUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AdminGetUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AdminSaveUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AdminSaveUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AdminSaveUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *int64
}

// Status returns HTTPResponse.Status
func (r AddCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CollapseCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CollapseCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CollapseCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCategoryEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Entries
}

// Status returns HTTPResponse.Status
func (r GetCategoryEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCategoryEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCategoryEntriesAsFeedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetCategoryEntriesAsFeedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCategoryEntriesAsFeedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRootCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Category
}

// Status returns HTTPResponse.Status
func (r GetRootCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRootCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MarkCategoryEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MarkCategoryEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MarkCategoryEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModifyCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ModifyCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModifyCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUnreadCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *[]UnreadCount
}

// Status returns HTTPResponse.Status
func (r GetUnreadCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUnreadCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MarkEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MarkEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MarkEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MarkEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MarkEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MarkEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StarEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StarEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StarEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TagEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TagEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TagEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFeedEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Entries
}

// Status returns HTTPResponse.Status
func (r GetFeedEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFeedEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFeedEntriesAsFeedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetFeedEntriesAsFeedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFeedEntriesAsFeedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportOpmlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ExportOpmlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportOpmlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFeedFaviconResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetFeedFaviconResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFeedFaviconResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FetchFeedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *FeedInfo
}

// Status returns HTTPResponse.Status
func (r FetchFeedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchFeedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFeedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Subscription
}

// Status returns HTTPResponse.Status
func (r GetFeedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFeedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportOpmlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ImportOpmlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportOpmlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MarkFeedEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MarkFeedEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MarkFeedEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModifyFeedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ModifyFeedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModifyFeedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueueForRefreshResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r QueueForRefreshResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueueForRefreshResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueueAllForRefreshResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r QueueAllForRefreshResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueueAllForRefreshResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SubscribeFromUrlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SubscribeFromUrlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubscribeFromUrlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SubscribeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *int64
}

// Status returns HTTPResponse.Status
func (r SubscribeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubscribeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnsubscribeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnsubscribeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnsubscribeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServerInfosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ServerInfo
}

// Status returns HTTPResponse.Status
func (r GetServerInfosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServerInfosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProxiedImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetProxiedImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProxiedImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendPasswordResetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SendPasswordResetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendPasswordResetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasswordRecoveryCallbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PasswordRecoveryCallbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasswordRecoveryCallbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *UserModel
}

// Status returns HTTPResponse.Status
func (r GetUserProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SaveUserProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SaveUserProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SaveUserProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegisterUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RegisterUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegisterUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Settings
}

// Status returns HTTPResponse.Status
func (r GetUserSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SaveUserSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SaveUserSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SaveUserSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetMetricsWithResponse request returning *GetMetricsResponse
func (c *ClientWithResponses) GetMetricsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMetricsResponse, error) {
	rsp, err := c.GetMetrics(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMetricsResponse(rsp)
}

// GetApplicationSettingsWithResponse request returning *GetApplicationSettingsResponse
func (c *ClientWithResponses) GetApplicationSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetApplicationSettingsResponse, error) {
	rsp, err := c.GetApplicationSettings(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApplicationSettingsResponse(rsp)
}

// AdminDeleteUserWithBodyWithResponse request with arbitrary body returning *AdminDeleteUserResponse
func (c *ClientWithResponses) AdminDeleteUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AdminDeleteUserResponse, error) {
	rsp, err := c.AdminDeleteUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAdminDeleteUserResponse(rsp)
}

func (c *ClientWithResponses) AdminDeleteUserWithResponse(ctx context.Context, body AdminDeleteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AdminDeleteUserResponse, error) {
	rsp, err := c.AdminDeleteUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAdminDeleteUserResponse(rsp)
}

// AdminGetUserWithResponse request returning *AdminGetUserResponse
func (c *ClientWithResponses) AdminGetUserWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*AdminGetUserResponse, error) {
	rsp, err := c.AdminGetUser(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAdminGetUserResponse(rsp)
}

// AdminGetUsersWithResponse request returning *AdminGetUsersResponse
func (c *ClientWithResponses) AdminGetUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AdminGetUsersResponse, error) {
	rsp, err := c.AdminGetUsers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAdminGetUsersResponse(rsp)
}

// AdminSaveUserWithBodyWithResponse request with arbitrary body returning *AdminSaveUserResponse
func (c *ClientWithResponses) AdminSaveUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AdminSaveUserResponse, error) {
	rsp, err := c.AdminSaveUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAdminSaveUserResponse(rsp)
}

func (c *ClientWithResponses) AdminSaveUserWithResponse(ctx context.Context, body AdminSaveUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AdminSaveUserResponse, error) {
	rsp, err := c.AdminSaveUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAdminSaveUserResponse(rsp)
}

// AddCategoryWithBodyWithResponse request with arbitrary body returning *AddCategoryResponse
func (c *ClientWithResponses) AddCategoryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddCategoryResponse, error) {
	rsp, err := c.AddCategoryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddCategoryResponse(rsp)
}

func (c *ClientWithResponses) AddCategoryWithResponse(ctx context.Context, body AddCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*AddCategoryResponse, error) {
	rsp, err := c.AddCategory(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddCategoryResponse(rsp)
}

// CollapseCategoryWithBodyWithResponse request with arbitrary body returning *CollapseCategoryResponse
func (c *ClientWithResponses) CollapseCategoryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CollapseCategoryResponse, error) {
	rsp, err := c.CollapseCategoryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCollapseCategoryResponse(rsp)
}

func (c *ClientWithResponses) CollapseCategoryWithResponse(ctx context.Context, body CollapseCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*CollapseCategoryResponse, error) {
	rsp, err := c.CollapseCategory(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCollapseCategoryResponse(rsp)
}

// DeleteCategoryWithBodyWithResponse request with arbitrary body returning *DeleteCategoryResponse
func (c *ClientWithResponses) DeleteCategoryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteCategoryResponse, error) {
	rsp, err := c.DeleteCategoryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCategoryResponse(rsp)
}

func (c *ClientWithResponses) DeleteCategoryWithResponse(ctx context.Context, body DeleteCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteCategoryResponse, error) {
	rsp, err := c.DeleteCategory(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCategoryResponse(rsp)
}

// GetCategoryEntriesWithResponse request returning *GetCategoryEntriesResponse
func (c *ClientWithResponses) GetCategoryEntriesWithResponse(ctx context.Context, params *GetCategoryEntriesParams, reqEditors ...RequestEditorFn) (*GetCategoryEntriesResponse, error) {
	rsp, err := c.GetCategoryEntries(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCategoryEntriesResponse(rsp)
}

// GetCategoryEntriesAsFeedWithResponse request returning *GetCategoryEntriesAsFeedResponse
func (c *ClientWithResponses) GetCategoryEntriesAsFeedWithResponse(ctx context.Context, params *GetCategoryEntriesAsFeedParams, reqEditors ...RequestEditorFn) (*GetCategoryEntriesAsFeedResponse, error) {
	rsp, err := c.GetCategoryEntriesAsFeed(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCategoryEntriesAsFeedResponse(rsp)
}

// GetRootCategoryWithResponse request returning *GetRootCategoryResponse
func (c *ClientWithResponses) GetRootCategoryWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRootCategoryResponse, error) {
	rsp, err := c.GetRootCategory(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRootCategoryResponse(rsp)
}

// MarkCategoryEntriesWithBodyWithResponse request with arbitrary body returning *MarkCategoryEntriesResponse
func (c *ClientWithResponses) MarkCategoryEntriesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarkCategoryEntriesResponse, error) {
	rsp, err := c.MarkCategoryEntriesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkCategoryEntriesResponse(rsp)
}

func (c *ClientWithResponses) MarkCategoryEntriesWithResponse(ctx context.Context, body MarkCategoryEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*MarkCategoryEntriesResponse, error) {
	rsp, err := c.MarkCategoryEntries(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkCategoryEntriesResponse(rsp)
}

// ModifyCategoryWithBodyWithResponse request with arbitrary body returning *ModifyCategoryResponse
func (c *ClientWithResponses) ModifyCategoryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyCategoryResponse, error) {
	rsp, err := c.ModifyCategoryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyCategoryResponse(rsp)
}

func (c *ClientWithResponses) ModifyCategoryWithResponse(ctx context.Context, body ModifyCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyCategoryResponse, error) {
	rsp, err := c.ModifyCategory(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyCategoryResponse(rsp)
}

// GetUnreadCountWithResponse request returning *GetUnreadCountResponse
func (c *ClientWithResponses) GetUnreadCountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUnreadCountResponse, error) {
	rsp, err := c.GetUnreadCount(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUnreadCountResponse(rsp)
}

// MarkEntryWithBodyWithResponse request with arbitrary body returning *MarkEntryResponse
func (c *ClientWithResponses) MarkEntryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarkEntryResponse, error) {
	rsp, err := c.MarkEntryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkEntryResponse(rsp)
}

func (c *ClientWithResponses) MarkEntryWithResponse(ctx context.Context, body MarkEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*MarkEntryResponse, error) {
	rsp, err := c.MarkEntry(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkEntryResponse(rsp)
}

// MarkEntriesWithBodyWithResponse request with arbitrary body returning *MarkEntriesResponse
func (c *ClientWithResponses) MarkEntriesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarkEntriesResponse, error) {
	rsp, err := c.MarkEntriesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkEntriesResponse(rsp)
}

func (c *ClientWithResponses) MarkEntriesWithResponse(ctx context.Context, body MarkEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*MarkEntriesResponse, error) {
	rsp, err := c.MarkEntries(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkEntriesResponse(rsp)
}

// StarEntryWithBodyWithResponse request with arbitrary body returning *StarEntryResponse
func (c *ClientWithResponses) StarEntryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StarEntryResponse, error) {
	rsp, err := c.StarEntryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStarEntryResponse(rsp)
}

func (c *ClientWithResponses) StarEntryWithResponse(ctx context.Context, body StarEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*StarEntryResponse, error) {
	rsp, err := c.StarEntry(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStarEntryResponse(rsp)
}

// TagEntryWithBodyWithResponse request with arbitrary body returning *TagEntryResponse
func (c *ClientWithResponses) TagEntryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TagEntryResponse, error) {
	rsp, err := c.TagEntryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagEntryResponse(rsp)
}

func (c *ClientWithResponses) TagEntryWithResponse(ctx context.Context, body TagEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*TagEntryResponse, error) {
	rsp, err := c.TagEntry(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagEntryResponse(rsp)
}

// GetTagsWithResponse request returning *GetTagsResponse
func (c *ClientWithResponses) GetTagsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTagsResponse, error) {
	rsp, err := c.GetTags(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTagsResponse(rsp)
}

// GetFeedEntriesWithResponse request returning *GetFeedEntriesResponse
func (c *ClientWithResponses) GetFeedEntriesWithResponse(ctx context.Context, params *GetFeedEntriesParams, reqEditors ...RequestEditorFn) (*GetFeedEntriesResponse, error) {
	rsp, err := c.GetFeedEntries(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFeedEntriesResponse(rsp)
}

// GetFeedEntriesAsFeedWithResponse request returning *GetFeedEntriesAsFeedResponse
func (c *ClientWithResponses) GetFeedEntriesAsFeedWithResponse(ctx context.Context, params *GetFeedEntriesAsFeedParams, reqEditors ...RequestEditorFn) (*GetFeedEntriesAsFeedResponse, error) {
	rsp, err := c.GetFeedEntriesAsFeed(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFeedEntriesAsFeedResponse(rsp)
}

// ExportOpmlWithResponse request returning *ExportOpmlResponse
func (c *ClientWithResponses) ExportOpmlWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ExportOpmlResponse, error) {
	rsp, err := c.ExportOpml(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportOpmlResponse(rsp)
}

// GetFeedFaviconWithResponse request returning *GetFeedFaviconResponse
func (c *ClientWithResponses) GetFeedFaviconWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetFeedFaviconResponse, error) {
	rsp, err := c.GetFeedFavicon(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFeedFaviconResponse(rsp)
}

// FetchFeedWithBodyWithResponse request with arbitrary body returning *FetchFeedResponse
func (c *ClientWithResponses) FetchFeedWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FetchFeedResponse, error) {
	rsp, err := c.FetchFeedWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFetchFeedResponse(rsp)
}

func (c *ClientWithResponses) FetchFeedWithResponse(ctx context.Context, body FetchFeedJSONRequestBody, reqEditors ...RequestEditorFn) (*FetchFeedResponse, error) {
	rsp, err := c.FetchFeed(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFetchFeedResponse(rsp)
}

// GetFeedWithResponse request returning *GetFeedResponse
func (c *ClientWithResponses) GetFeedWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetFeedResponse, error) {
	rsp, err := c.GetFeed(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFeedResponse(rsp)
}

// ImportOpmlWithBodyWithResponse request with arbitrary body returning *ImportOpmlResponse
func (c *ClientWithResponses) ImportOpmlWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportOpmlResponse, error) {
	rsp, err := c.ImportOpmlWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportOpmlResponse(rsp)
}

// MarkFeedEntriesWithBodyWithResponse request with arbitrary body returning *MarkFeedEntriesResponse
func (c *ClientWithResponses) MarkFeedEntriesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarkFeedEntriesResponse, error) {
	rsp, err := c.MarkFeedEntriesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkFeedEntriesResponse(rsp)
}

func (c *ClientWithResponses) MarkFeedEntriesWithResponse(ctx context.Context, body MarkFeedEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*MarkFeedEntriesResponse, error) {
	rsp, err := c.MarkFeedEntries(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkFeedEntriesResponse(rsp)
}

// ModifyFeedWithBodyWithResponse request with arbitrary body returning *ModifyFeedResponse
func (c *ClientWithResponses) ModifyFeedWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyFeedResponse, error) {
	rsp, err := c.ModifyFeedWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyFeedResponse(rsp)
}

func (c *ClientWithResponses) ModifyFeedWithResponse(ctx context.Context, body ModifyFeedJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyFeedResponse, error) {
	rsp, err := c.ModifyFeed(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyFeedResponse(rsp)
}

// QueueForRefreshWithBodyWithResponse request with arbitrary body returning *QueueForRefreshResponse
func (c *ClientWithResponses) QueueForRefreshWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueueForRefreshResponse, error) {
	rsp, err := c.QueueForRefreshWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueueForRefreshResponse(rsp)
}

func (c *ClientWithResponses) QueueForRefreshWithResponse(ctx context.Context, body QueueForRefreshJSONRequestBody, reqEditors ...RequestEditorFn) (*QueueForRefreshResponse, error) {
	rsp, err := c.QueueForRefresh(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueueForRefreshResponse(rsp)
}

// QueueAllForRefreshWithResponse request returning *QueueAllForRefreshResponse
func (c *ClientWithResponses) QueueAllForRefreshWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*QueueAllForRefreshResponse, error) {
	rsp, err := c.QueueAllForRefresh(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueueAllForRefreshResponse(rsp)
}

// SubscribeFromUrlWithResponse request returning *SubscribeFromUrlResponse
func (c *ClientWithResponses) SubscribeFromUrlWithResponse(ctx context.Context, params *SubscribeFromUrlParams, reqEditors ...RequestEditorFn) (*SubscribeFromUrlResponse, error) {
	rsp, err := c.SubscribeFromUrl(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubscribeFromUrlResponse(rsp)
}

// SubscribeWithBodyWithResponse request with arbitrary body returning *SubscribeResponse
func (c *ClientWithResponses) SubscribeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubscribeResponse, error) {
	rsp, err := c.SubscribeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubscribeResponse(rsp)
}

func (c *ClientWithResponses) SubscribeWithResponse(ctx context.Context, body SubscribeJSONRequestBody, reqEditors ...RequestEditorFn) (*SubscribeResponse, error) {
	rsp, err := c.Subscribe(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubscribeResponse(rsp)
}

// UnsubscribeWithBodyWithResponse request with arbitrary body returning *UnsubscribeResponse
func (c *ClientWithResponses) UnsubscribeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnsubscribeResponse, error) {
	rsp, err := c.UnsubscribeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnsubscribeResponse(rsp)
}

func (c *ClientWithResponses) UnsubscribeWithResponse(ctx context.Context, body UnsubscribeJSONRequestBody, reqEditors ...RequestEditorFn) (*UnsubscribeResponse, error) {
	rsp, err := c.Unsubscribe(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnsubscribeResponse(rsp)
}

// GetServerInfosWithResponse request returning *GetServerInfosResponse
func (c *ClientWithResponses) GetServerInfosWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetServerInfosResponse, error) {
	rsp, err := c.GetServerInfos(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServerInfosResponse(rsp)
}

// GetProxiedImageWithResponse request returning *GetProxiedImageResponse
func (c *ClientWithResponses) GetProxiedImageWithResponse(ctx context.Context, params *GetProxiedImageParams, reqEditors ...RequestEditorFn) (*GetProxiedImageResponse, error) {
	rsp, err := c.GetProxiedImage(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProxiedImageResponse(rsp)
}

// LoginWithBodyWithResponse request with arbitrary body returning *LoginResponse
func (c *ClientWithResponses) LoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.LoginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

func (c *ClientWithResponses) LoginWithResponse(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.Login(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

// SendPasswordResetWithBodyWithResponse request with arbitrary body returning *SendPasswordResetResponse
func (c *ClientWithResponses) SendPasswordResetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendPasswordResetResponse, error) {
	rsp, err := c.SendPasswordResetWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendPasswordResetResponse(rsp)
}

func (c *ClientWithResponses) SendPasswordResetWithResponse(ctx context.Context, body SendPasswordResetJSONRequestBody, reqEditors ...RequestEditorFn) (*SendPasswordResetResponse, error) {
	rsp, err := c.SendPasswordReset(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendPasswordResetResponse(rsp)
}

// PasswordRecoveryCallbackWithResponse request returning *PasswordRecoveryCallbackResponse
func (c *ClientWithResponses) PasswordRecoveryCallbackWithResponse(ctx context.Context, params *PasswordRecoveryCallbackParams, reqEditors ...RequestEditorFn) (*PasswordRecoveryCallbackResponse, error) {
	rsp, err := c.PasswordRecoveryCallback(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasswordRecoveryCallbackResponse(rsp)
}

// GetUserProfileWithResponse request returning *GetUserProfileResponse
func (c *ClientWithResponses) GetUserProfileWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserProfileResponse, error) {
	rsp, err := c.GetUserProfile(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserProfileResponse(rsp)
}

// SaveUserProfileWithBodyWithResponse request with arbitrary body returning *SaveUserProfileResponse
func (c *ClientWithResponses) SaveUserProfileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveUserProfileResponse, error) {
	rsp, err := c.SaveUserProfileWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveUserProfileResponse(rsp)
}

func (c *ClientWithResponses) SaveUserProfileWithResponse(ctx context.Context, body SaveUserProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*SaveUserProfileResponse, error) {
	rsp, err := c.SaveUserProfile(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveUserProfileResponse(rsp)
}

// DeleteUserWithResponse request returning *DeleteUserResponse
func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error) {
	rsp, err := c.DeleteUser(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResponse(rsp)
}

// RegisterUserWithBodyWithResponse request with arbitrary body returning *RegisterUserResponse
func (c *ClientWithResponses) RegisterUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterUserResponse, error) {
	rsp, err := c.RegisterUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterUserResponse(rsp)
}

func (c *ClientWithResponses) RegisterUserWithResponse(ctx context.Context, body RegisterUserJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterUserResponse, error) {
	rsp, err := c.RegisterUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterUserResponse(rsp)
}

// GetUserSettingsWithResponse request returning *GetUserSettingsResponse
func (c *ClientWithResponses) GetUserSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserSettingsResponse, error) {
	rsp, err := c.GetUserSettings(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserSettingsResponse(rsp)
}

// SaveUserSettingsWithBodyWithResponse request with arbitrary body returning *SaveUserSettingsResponse
func (c *ClientWithResponses) SaveUserSettingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveUserSettingsResponse, error) {
	rsp, err := c.SaveUserSettingsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveUserSettingsResponse(rsp)
}

func (c *ClientWithResponses) SaveUserSettingsWithResponse(ctx context.Context, body SaveUserSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*SaveUserSettingsResponse, error) {
	rsp, err := c.SaveUserSettings(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveUserSettingsResponse(rsp)
}

// ParseGetMetricsResponse parses an HTTP response from a GetMetricsWithResponse call
func ParseGetMetricsResponse(rsp *http.Response) (*GetMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApplicationSettingsResponse parses an HTTP response from a GetApplicationSettingsWithResponse call
func ParseGetApplicationSettingsResponse(rsp *http.Response) (*GetApplicationSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApplicationSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ApplicationSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAdminDeleteUserResponse parses an HTTP response from a AdminDeleteUserWithResponse call
func ParseAdminDeleteUserResponse(rsp *http.Response) (*AdminDeleteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AdminDeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAdminGetUserResponse parses an HTTP response from a AdminGetUserWithResponse call
func ParseAdminGetUserResponse(rsp *http.Response) (*AdminGetUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AdminGetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UserModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAdminGetUsersResponse parses an HTTP response from a AdminGetUsersWithResponse call
func ParseAdminGetUsersResponse(rsp *http.Response) (*AdminGetUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AdminGetUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest []UserModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAdminSaveUserResponse parses an HTTP response from a AdminSaveUserWithResponse call
func ParseAdminSaveUserResponse(rsp *http.Response) (*AdminSaveUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AdminSaveUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAddCategoryResponse parses an HTTP response from a AddCategoryWithResponse call
func ParseAddCategoryResponse(rsp *http.Response) (*AddCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest int64
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCollapseCategoryResponse parses an HTTP response from a CollapseCategoryWithResponse call
func ParseCollapseCategoryResponse(rsp *http.Response) (*CollapseCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CollapseCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteCategoryResponse parses an HTTP response from a DeleteCategoryWithResponse call
func ParseDeleteCategoryResponse(rsp *http.Response) (*DeleteCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCategoryEntriesResponse parses an HTTP response from a GetCategoryEntriesWithResponse call
func ParseGetCategoryEntriesResponse(rsp *http.Response) (*GetCategoryEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCategoryEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Entries
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCategoryEntriesAsFeedResponse parses an HTTP response from a GetCategoryEntriesAsFeedWithResponse call
func ParseGetCategoryEntriesAsFeedResponse(rsp *http.Response) (*GetCategoryEntriesAsFeedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCategoryEntriesAsFeedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetRootCategoryResponse parses an HTTP response from a GetRootCategoryWithResponse call
func ParseGetRootCategoryResponse(rsp *http.Response) (*GetRootCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRootCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Category
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMarkCategoryEntriesResponse parses an HTTP response from a MarkCategoryEntriesWithResponse call
func ParseMarkCategoryEntriesResponse(rsp *http.Response) (*MarkCategoryEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MarkCategoryEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseModifyCategoryResponse parses an HTTP response from a ModifyCategoryWithResponse call
func ParseModifyCategoryResponse(rsp *http.Response) (*ModifyCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModifyCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUnreadCountResponse parses an HTTP response from a GetUnreadCountWithResponse call
func ParseGetUnreadCountResponse(rsp *http.Response) (*GetUnreadCountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUnreadCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest []UnreadCount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMarkEntryResponse parses an HTTP response from a MarkEntryWithResponse call
func ParseMarkEntryResponse(rsp *http.Response) (*MarkEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MarkEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMarkEntriesResponse parses an HTTP response from a MarkEntriesWithResponse call
func ParseMarkEntriesResponse(rsp *http.Response) (*MarkEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MarkEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStarEntryResponse parses an HTTP response from a StarEntryWithResponse call
func ParseStarEntryResponse(rsp *http.Response) (*StarEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StarEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTagEntryResponse parses an HTTP response from a TagEntryWithResponse call
func ParseTagEntryResponse(rsp *http.Response) (*TagEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TagEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetTagsResponse parses an HTTP response from a GetTagsWithResponse call
func ParseGetTagsResponse(rsp *http.Response) (*GetTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetFeedEntriesResponse parses an HTTP response from a GetFeedEntriesWithResponse call
func ParseGetFeedEntriesResponse(rsp *http.Response) (*GetFeedEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFeedEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Entries
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetFeedEntriesAsFeedResponse parses an HTTP response from a GetFeedEntriesAsFeedWithResponse call
func ParseGetFeedEntriesAsFeedResponse(rsp *http.Response) (*GetFeedEntriesAsFeedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFeedEntriesAsFeedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExportOpmlResponse parses an HTTP response from a ExportOpmlWithResponse call
func ParseExportOpmlResponse(rsp *http.Response) (*ExportOpmlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportOpmlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetFeedFaviconResponse parses an HTTP response from a GetFeedFaviconWithResponse call
func ParseGetFeedFaviconResponse(rsp *http.Response) (*GetFeedFaviconResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFeedFaviconResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFetchFeedResponse parses an HTTP response from a FetchFeedWithResponse call
func ParseFetchFeedResponse(rsp *http.Response) (*FetchFeedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FetchFeedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest FeedInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetFeedResponse parses an HTTP response from a GetFeedWithResponse call
func ParseGetFeedResponse(rsp *http.Response) (*GetFeedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFeedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Subscription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseImportOpmlResponse parses an HTTP response from a ImportOpmlWithResponse call
func ParseImportOpmlResponse(rsp *http.Response) (*ImportOpmlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ImportOpmlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMarkFeedEntriesResponse parses an HTTP response from a MarkFeedEntriesWithResponse call
func ParseMarkFeedEntriesResponse(rsp *http.Response) (*MarkFeedEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MarkFeedEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseModifyFeedResponse parses an HTTP response from a ModifyFeedWithResponse call
func ParseModifyFeedResponse(rsp *http.Response) (*ModifyFeedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModifyFeedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueueForRefreshResponse parses an HTTP response from a QueueForRefreshWithResponse call
func ParseQueueForRefreshResponse(rsp *http.Response) (*QueueForRefreshResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueueForRefreshResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueueAllForRefreshResponse parses an HTTP response from a QueueAllForRefreshWithResponse call
func ParseQueueAllForRefreshResponse(rsp *http.Response) (*QueueAllForRefreshResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueueAllForRefreshResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSubscribeFromUrlResponse parses an HTTP response from a SubscribeFromUrlWithResponse call
func ParseSubscribeFromUrlResponse(rsp *http.Response) (*SubscribeFromUrlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubscribeFromUrlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSubscribeResponse parses an HTTP response from a SubscribeWithResponse call
func ParseSubscribeResponse(rsp *http.Response) (*SubscribeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubscribeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest int64
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUnsubscribeResponse parses an HTTP response from a UnsubscribeWithResponse call
func ParseUnsubscribeResponse(rsp *http.Response) (*UnsubscribeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnsubscribeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetServerInfosResponse parses an HTTP response from a GetServerInfosWithResponse call
func ParseGetServerInfosResponse(rsp *http.Response) (*GetServerInfosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServerInfosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ServerInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetProxiedImageResponse parses an HTTP response from a GetProxiedImageWithResponse call
func ParseGetProxiedImageResponse(rsp *http.Response) (*GetProxiedImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProxiedImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseLoginResponse parses an HTTP response from a LoginWithResponse call
func ParseLoginResponse(rsp *http.Response) (*LoginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSendPasswordResetResponse parses an HTTP response from a SendPasswordResetWithResponse call
func ParseSendPasswordResetResponse(rsp *http.Response) (*SendPasswordResetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendPasswordResetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePasswordRecoveryCallbackResponse parses an HTTP response from a PasswordRecoveryCallbackWithResponse call
func ParsePasswordRecoveryCallbackResponse(rsp *http.Response) (*PasswordRecoveryCallbackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasswordRecoveryCallbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUserProfileResponse parses an HTTP response from a GetUserProfileWithResponse call
func ParseGetUserProfileResponse(rsp *http.Response) (*GetUserProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UserModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSaveUserProfileResponse parses an HTTP response from a SaveUserProfileWithResponse call
func ParseSaveUserProfileResponse(rsp *http.Response) (*SaveUserProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SaveUserProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteUserResponse parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResponse(rsp *http.Response) (*DeleteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRegisterUserResponse parses an HTTP response from a RegisterUserWithResponse call
func ParseRegisterUserResponse(rsp *http.Response) (*RegisterUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegisterUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUserSettingsResponse parses an HTTP response from a GetUserSettingsWithResponse call
func ParseGetUserSettingsResponse(rsp *http.Response) (*GetUserSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Settings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSaveUserSettingsResponse parses an HTTP response from a SaveUserSettingsWithResponse call
func ParseSaveUserSettingsResponse(rsp *http.Response) (*SaveUserSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SaveUserSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Retrieve server metrics
	// (GET /admin/metrics)
	GetMetrics(ctx echo.Context) error
	// Retrieve application settings
	// (GET /admin/settings)
	GetApplicationSettings(ctx echo.Context) error
	// Delete a user
	// (POST /admin/user/delete)
	AdminDeleteUser(ctx echo.Context) error
	// Get user information
	// (GET /admin/user/get/{id})
	AdminGetUser(ctx echo.Context, id int64) error
	// Get all users
	// (GET /admin/user/getAll)
	AdminGetUsers(ctx echo.Context) error
	// Save or update a user
	// (POST /admin/user/save)
	AdminSaveUser(ctx echo.Context) error
	// Add a category
	// (POST /category/add)
	AddCategory(ctx echo.Context) error
	// Collapse a category
	// (POST /category/collapse)
	CollapseCategory(ctx echo.Context) error
	// Delete a category
	// (POST /category/delete)
	DeleteCategory(ctx echo.Context) error
	// Get category entries
	// (GET /category/entries)
	GetCategoryEntries(ctx echo.Context, params GetCategoryEntriesParams) error
	// Get category entries as feed
	// (GET /category/entriesAsFeed)
	GetCategoryEntriesAsFeed(ctx echo.Context, params GetCategoryEntriesAsFeedParams) error
	// Get root category
	// (GET /category/get)
	GetRootCategory(ctx echo.Context) error
	// Mark category entries
	// (POST /category/mark)
	MarkCategoryEntries(ctx echo.Context) error
	// Rename a category
	// (POST /category/modify)
	ModifyCategory(ctx echo.Context) error
	// Get unread count for feed subscriptions
	// (GET /category/unreadCount)
	GetUnreadCount(ctx echo.Context) error
	// Mark a feed entry
	// (POST /entry/mark)
	MarkEntry(ctx echo.Context) error
	// Mark multiple feed entries
	// (POST /entry/markMultiple)
	MarkEntries(ctx echo.Context) error
	// Star a feed entry
	// (POST /entry/star)
	StarEntry(ctx echo.Context) error
	// Set feed entry tags
	// (POST /entry/tag)
	TagEntry(ctx echo.Context) error
	// Get list of tags for the user
	// (GET /entry/tags)
	GetTags(ctx echo.Context) error
	// Get feed entries
	// (GET /feed/entries)
	GetFeedEntries(ctx echo.Context, params GetFeedEntriesParams) error
	// Get feed entries as a feed
	// (GET /feed/entriesAsFeed)
	GetFeedEntriesAsFeed(ctx echo.Context, params GetFeedEntriesAsFeedParams) error
	// OPML export
	// (GET /feed/export)
	ExportOpml(ctx echo.Context) error
	// Fetch a feed's icon
	// (GET /feed/favicon/{id})
	GetFeedFavicon(ctx echo.Context, id int64) error
	// Fetch a feed
	// (POST /feed/fetch)
	FetchFeed(ctx echo.Context) error
	// get feed
	// (GET /feed/get/{id})
	GetFeed(ctx echo.Context, id int64) error
	// OPML import
	// (POST /feed/import)
	ImportOpml(ctx echo.Context) error
	// Mark feed entries
	// (POST /feed/mark)
	MarkFeedEntries(ctx echo.Context) error
	// Modify a subscription
	// (POST /feed/modify)
	ModifyFeed(ctx echo.Context) error
	// Queue a feed for refresh
	// (POST /feed/refresh)
	QueueForRefresh(ctx echo.Context) error
	// Queue all feeds of the user for refresh
	// (GET /feed/refreshAll)
	QueueAllForRefresh(ctx echo.Context) error
	// Subscribe to a feed
	// (GET /feed/subscribe)
	SubscribeFromUrl(ctx echo.Context, params SubscribeFromUrlParams) error
	// Subscribe to a feed
	// (POST /feed/subscribe)
	Subscribe(ctx echo.Context) error
	// Unsubscribe from a feed
	// (POST /feed/unsubscribe)
	Unsubscribe(ctx echo.Context) error
	// Get server infos
	// (GET /server/get)
	GetServerInfos(ctx echo.Context) error
	// proxy image
	// (GET /server/proxy)
	GetProxiedImage(ctx echo.Context, params GetProxiedImageParams) error
	// Login and create a session
	// (POST /user/login)
	Login(ctx echo.Context) error
	// send a password reset email
	// (POST /user/passwordReset)
	SendPasswordReset(ctx echo.Context) error

	// (GET /user/passwordResetCallback)
	PasswordRecoveryCallback(ctx echo.Context, params PasswordRecoveryCallbackParams) error
	// Retrieve user's profile
	// (GET /user/profile)
	GetUserProfile(ctx echo.Context) error
	// Save user's profile
	// (POST /user/profile)
	SaveUserProfile(ctx echo.Context) error
	// Delete the user account
	// (POST /user/profile/deleteAccount)
	DeleteUser(ctx echo.Context) error
	// Register a new account
	// (POST /user/register)
	RegisterUser(ctx echo.Context) error
	// Retrieve user settings
	// (GET /user/settings)
	GetUserSettings(ctx echo.Context) error
	// Save user settings
	// (POST /user/settings)
	SaveUserSettings(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetMetrics converts echo context to params.
func (w *ServerInterfaceWrapper) GetMetrics(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMetrics(ctx)
	return err
}

// GetApplicationSettings converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationSettings(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationSettings(ctx)
	return err
}

// AdminDeleteUser converts echo context to params.
func (w *ServerInterfaceWrapper) AdminDeleteUser(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdminDeleteUser(ctx)
	return err
}

// AdminGetUser converts echo context to params.
func (w *ServerInterfaceWrapper) AdminGetUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdminGetUser(ctx, id)
	return err
}

// AdminGetUsers converts echo context to params.
func (w *ServerInterfaceWrapper) AdminGetUsers(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdminGetUsers(ctx)
	return err
}

// AdminSaveUser converts echo context to params.
func (w *ServerInterfaceWrapper) AdminSaveUser(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdminSaveUser(ctx)
	return err
}

// AddCategory converts echo context to params.
func (w *ServerInterfaceWrapper) AddCategory(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AddCategory(ctx)
	return err
}

// CollapseCategory converts echo context to params.
func (w *ServerInterfaceWrapper) CollapseCategory(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CollapseCategory(ctx)
	return err
}

// DeleteCategory converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteCategory(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteCategory(ctx)
	return err
}

// GetCategoryEntries converts echo context to params.
func (w *ServerInterfaceWrapper) GetCategoryEntries(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCategoryEntriesParams
	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Required query parameter "readType" -------------

	err = runtime.BindQueryParameter("form", true, true, "readType", ctx.QueryParams(), &params.ReadType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter readType: %s", err))
	}

	// ------------- Optional query parameter "newerThan" -------------

	err = runtime.BindQueryParameter("form", true, false, "newerThan", ctx.QueryParams(), &params.NewerThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter newerThan: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", ctx.QueryParams(), &params.Order)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order: %s", err))
	}

	// ------------- Optional query parameter "keywords" -------------

	err = runtime.BindQueryParameter("form", true, false, "keywords", ctx.QueryParams(), &params.Keywords)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter keywords: %s", err))
	}

	// ------------- Optional query parameter "onlyIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "onlyIds", ctx.QueryParams(), &params.OnlyIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter onlyIds: %s", err))
	}

	// ------------- Optional query parameter "excludedSubscriptionIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "excludedSubscriptionIds", ctx.QueryParams(), &params.ExcludedSubscriptionIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter excludedSubscriptionIds: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCategoryEntries(ctx, params)
	return err
}

// GetCategoryEntriesAsFeed converts echo context to params.
func (w *ServerInterfaceWrapper) GetCategoryEntriesAsFeed(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCategoryEntriesAsFeedParams
	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Required query parameter "readType" -------------

	err = runtime.BindQueryParameter("form", true, true, "readType", ctx.QueryParams(), &params.ReadType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter readType: %s", err))
	}

	// ------------- Optional query parameter "newerThan" -------------

	err = runtime.BindQueryParameter("form", true, false, "newerThan", ctx.QueryParams(), &params.NewerThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter newerThan: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", ctx.QueryParams(), &params.Order)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order: %s", err))
	}

	// ------------- Optional query parameter "keywords" -------------

	err = runtime.BindQueryParameter("form", true, false, "keywords", ctx.QueryParams(), &params.Keywords)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter keywords: %s", err))
	}

	// ------------- Optional query parameter "onlyIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "onlyIds", ctx.QueryParams(), &params.OnlyIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter onlyIds: %s", err))
	}

	// ------------- Optional query parameter "excludedSubscriptionIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "excludedSubscriptionIds", ctx.QueryParams(), &params.ExcludedSubscriptionIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter excludedSubscriptionIds: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCategoryEntriesAsFeed(ctx, params)
	return err
}

// GetRootCategory converts echo context to params.
func (w *ServerInterfaceWrapper) GetRootCategory(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRootCategory(ctx)
	return err
}

// MarkCategoryEntries converts echo context to params.
func (w *ServerInterfaceWrapper) MarkCategoryEntries(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.MarkCategoryEntries(ctx)
	return err
}

// ModifyCategory converts echo context to params.
func (w *ServerInterfaceWrapper) ModifyCategory(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ModifyCategory(ctx)
	return err
}

// GetUnreadCount converts echo context to params.
func (w *ServerInterfaceWrapper) GetUnreadCount(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUnreadCount(ctx)
	return err
}

// MarkEntry converts echo context to params.
func (w *ServerInterfaceWrapper) MarkEntry(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.MarkEntry(ctx)
	return err
}

// MarkEntries converts echo context to params.
func (w *ServerInterfaceWrapper) MarkEntries(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.MarkEntries(ctx)
	return err
}

// StarEntry converts echo context to params.
func (w *ServerInterfaceWrapper) StarEntry(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.StarEntry(ctx)
	return err
}

// TagEntry converts echo context to params.
func (w *ServerInterfaceWrapper) TagEntry(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TagEntry(ctx)
	return err
}

// GetTags converts echo context to params.
func (w *ServerInterfaceWrapper) GetTags(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTags(ctx)
	return err
}

// GetFeedEntries converts echo context to params.
func (w *ServerInterfaceWrapper) GetFeedEntries(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFeedEntriesParams
	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Required query parameter "readType" -------------

	err = runtime.BindQueryParameter("form", true, true, "readType", ctx.QueryParams(), &params.ReadType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter readType: %s", err))
	}

	// ------------- Optional query parameter "newerThan" -------------

	err = runtime.BindQueryParameter("form", true, false, "newerThan", ctx.QueryParams(), &params.NewerThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter newerThan: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", ctx.QueryParams(), &params.Order)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order: %s", err))
	}

	// ------------- Optional query parameter "keywords" -------------

	err = runtime.BindQueryParameter("form", true, false, "keywords", ctx.QueryParams(), &params.Keywords)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter keywords: %s", err))
	}

	// ------------- Optional query parameter "onlyIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "onlyIds", ctx.QueryParams(), &params.OnlyIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter onlyIds: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFeedEntries(ctx, params)
	return err
}

// GetFeedEntriesAsFeed converts echo context to params.
func (w *ServerInterfaceWrapper) GetFeedEntriesAsFeed(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFeedEntriesAsFeedParams
	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Required query parameter "readType" -------------

	err = runtime.BindQueryParameter("form", true, true, "readType", ctx.QueryParams(), &params.ReadType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter readType: %s", err))
	}

	// ------------- Optional query parameter "newerThan" -------------

	err = runtime.BindQueryParameter("form", true, false, "newerThan", ctx.QueryParams(), &params.NewerThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter newerThan: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", ctx.QueryParams(), &params.Order)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order: %s", err))
	}

	// ------------- Optional query parameter "keywords" -------------

	err = runtime.BindQueryParameter("form", true, false, "keywords", ctx.QueryParams(), &params.Keywords)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter keywords: %s", err))
	}

	// ------------- Optional query parameter "onlyIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "onlyIds", ctx.QueryParams(), &params.OnlyIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter onlyIds: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFeedEntriesAsFeed(ctx, params)
	return err
}

// ExportOpml converts echo context to params.
func (w *ServerInterfaceWrapper) ExportOpml(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ExportOpml(ctx)
	return err
}

// GetFeedFavicon converts echo context to params.
func (w *ServerInterfaceWrapper) GetFeedFavicon(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFeedFavicon(ctx, id)
	return err
}

// FetchFeed converts echo context to params.
func (w *ServerInterfaceWrapper) FetchFeed(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.FetchFeed(ctx)
	return err
}

// GetFeed converts echo context to params.
func (w *ServerInterfaceWrapper) GetFeed(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFeed(ctx, id)
	return err
}

// ImportOpml converts echo context to params.
func (w *ServerInterfaceWrapper) ImportOpml(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ImportOpml(ctx)
	return err
}

// MarkFeedEntries converts echo context to params.
func (w *ServerInterfaceWrapper) MarkFeedEntries(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.MarkFeedEntries(ctx)
	return err
}

// ModifyFeed converts echo context to params.
func (w *ServerInterfaceWrapper) ModifyFeed(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ModifyFeed(ctx)
	return err
}

// QueueForRefresh converts echo context to params.
func (w *ServerInterfaceWrapper) QueueForRefresh(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.QueueForRefresh(ctx)
	return err
}

// QueueAllForRefresh converts echo context to params.
func (w *ServerInterfaceWrapper) QueueAllForRefresh(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.QueueAllForRefresh(ctx)
	return err
}

// SubscribeFromUrl converts echo context to params.
func (w *ServerInterfaceWrapper) SubscribeFromUrl(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SubscribeFromUrlParams
	// ------------- Required query parameter "url" -------------

	err = runtime.BindQueryParameter("form", true, true, "url", ctx.QueryParams(), &params.Url)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter url: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SubscribeFromUrl(ctx, params)
	return err
}

// Subscribe converts echo context to params.
func (w *ServerInterfaceWrapper) Subscribe(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Subscribe(ctx)
	return err
}

// Unsubscribe converts echo context to params.
func (w *ServerInterfaceWrapper) Unsubscribe(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Unsubscribe(ctx)
	return err
}

// GetServerInfos converts echo context to params.
func (w *ServerInterfaceWrapper) GetServerInfos(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetServerInfos(ctx)
	return err
}

// GetProxiedImage converts echo context to params.
func (w *ServerInterfaceWrapper) GetProxiedImage(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProxiedImageParams
	// ------------- Required query parameter "u" -------------

	err = runtime.BindQueryParameter("form", true, true, "u", ctx.QueryParams(), &params.U)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter u: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProxiedImage(ctx, params)
	return err
}

// Login converts echo context to params.
func (w *ServerInterfaceWrapper) Login(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Login(ctx)
	return err
}

// SendPasswordReset converts echo context to params.
func (w *ServerInterfaceWrapper) SendPasswordReset(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SendPasswordReset(ctx)
	return err
}

// PasswordRecoveryCallback converts echo context to params.
func (w *ServerInterfaceWrapper) PasswordRecoveryCallback(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PasswordRecoveryCallbackParams
	// ------------- Required query parameter "email" -------------

	err = runtime.BindQueryParameter("form", true, true, "email", ctx.QueryParams(), &params.Email)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter email: %s", err))
	}

	// ------------- Required query parameter "token" -------------

	err = runtime.BindQueryParameter("form", true, true, "token", ctx.QueryParams(), &params.Token)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter token: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PasswordRecoveryCallback(ctx, params)
	return err
}

// GetUserProfile converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserProfile(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUserProfile(ctx)
	return err
}

// SaveUserProfile converts echo context to params.
func (w *ServerInterfaceWrapper) SaveUserProfile(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SaveUserProfile(ctx)
	return err
}

// DeleteUser converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteUser(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteUser(ctx)
	return err
}

// RegisterUser converts echo context to params.
func (w *ServerInterfaceWrapper) RegisterUser(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RegisterUser(ctx)
	return err
}

// GetUserSettings converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserSettings(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUserSettings(ctx)
	return err
}

// SaveUserSettings converts echo context to params.
func (w *ServerInterfaceWrapper) SaveUserSettings(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SaveUserSettings(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/admin/metrics", wrapper.GetMetrics)
	router.GET(baseURL+"/admin/settings", wrapper.GetApplicationSettings)
	router.POST(baseURL+"/admin/user/delete", wrapper.AdminDeleteUser)
	router.GET(baseURL+"/admin/user/get/:id", wrapper.AdminGetUser)
	router.GET(baseURL+"/admin/user/getAll", wrapper.AdminGetUsers)
	router.POST(baseURL+"/admin/user/save", wrapper.AdminSaveUser)
	router.POST(baseURL+"/category/add", wrapper.AddCategory)
	router.POST(baseURL+"/category/collapse", wrapper.CollapseCategory)
	router.POST(baseURL+"/category/delete", wrapper.DeleteCategory)
	router.GET(baseURL+"/category/entries", wrapper.GetCategoryEntries)
	router.GET(baseURL+"/category/entriesAsFeed", wrapper.GetCategoryEntriesAsFeed)
	router.GET(baseURL+"/category/get", wrapper.GetRootCategory)
	router.POST(baseURL+"/category/mark", wrapper.MarkCategoryEntries)
	router.POST(baseURL+"/category/modify", wrapper.ModifyCategory)
	router.GET(baseURL+"/category/unreadCount", wrapper.GetUnreadCount)
	router.POST(baseURL+"/entry/mark", wrapper.MarkEntry)
	router.POST(baseURL+"/entry/markMultiple", wrapper.MarkEntries)
	router.POST(baseURL+"/entry/star", wrapper.StarEntry)
	router.POST(baseURL+"/entry/tag", wrapper.TagEntry)
	router.GET(baseURL+"/entry/tags", wrapper.GetTags)
	router.GET(baseURL+"/feed/entries", wrapper.GetFeedEntries)
	router.GET(baseURL+"/feed/entriesAsFeed", wrapper.GetFeedEntriesAsFeed)
	router.GET(baseURL+"/feed/export", wrapper.ExportOpml)
	router.GET(baseURL+"/feed/favicon/:id", wrapper.GetFeedFavicon)
	router.POST(baseURL+"/feed/fetch", wrapper.FetchFeed)
	router.GET(baseURL+"/feed/get/:id", wrapper.GetFeed)
	router.POST(baseURL+"/feed/import", wrapper.ImportOpml)
	router.POST(baseURL+"/feed/mark", wrapper.MarkFeedEntries)
	router.POST(baseURL+"/feed/modify", wrapper.ModifyFeed)
	router.POST(baseURL+"/feed/refresh", wrapper.QueueForRefresh)
	router.GET(baseURL+"/feed/refreshAll", wrapper.QueueAllForRefresh)
	router.GET(baseURL+"/feed/subscribe", wrapper.SubscribeFromUrl)
	router.POST(baseURL+"/feed/subscribe", wrapper.Subscribe)
	router.POST(baseURL+"/feed/unsubscribe", wrapper.Unsubscribe)
	router.GET(baseURL+"/server/get", wrapper.GetServerInfos)
	router.GET(baseURL+"/server/proxy", wrapper.GetProxiedImage)
	router.POST(baseURL+"/user/login", wrapper.Login)
	router.POST(baseURL+"/user/passwordReset", wrapper.SendPasswordReset)
	router.GET(baseURL+"/user/passwordResetCallback", wrapper.PasswordRecoveryCallback)
	router.GET(baseURL+"/user/profile", wrapper.GetUserProfile)
	router.POST(baseURL+"/user/profile", wrapper.SaveUserProfile)
	router.POST(baseURL+"/user/profile/deleteAccount", wrapper.DeleteUser)
	router.POST(baseURL+"/user/register", wrapper.RegisterUser)
	router.GET(baseURL+"/user/settings", wrapper.GetUserSettings)
	router.POST(baseURL+"/user/settings", wrapper.SaveUserSettings)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9bW/cOJLwXyH6eYDsAb3jTLI7uPM3T15mvZdMco6DPWAwWLCl6m6OKVJDUm73Dfzf",
	"D3yTKKmoVnvScWYv3+wWRRarWO/F0m+LQla1FCCMXpz/ttDFFirq/rwoyxfUwEaq/RX82oA29tcSdKFY",
	"bZgUi3M7hsRBJI5aLmola1CGgZtI0ArGr7pfl4uK3r0BsTHbxfm3z/59uTD7GhbnC20UE5vF/XJRUwXC",
	"XJbjGfwTUsT1WbkkbE2o2B+e9365UPBrwxSUi/OfPDA/t6Pk6hcojF39oqyY+EBv4aMGlUWDHUDsCMLE",
	"WqqKut+HeKB2rvHLjXtPE/+4hWElJQcqLBBQUcYzL7pnyb5H+ANBVxwQ9NGikI0wRBtqGo0uzMocuOVi",
	"ufA7XZwvmDDf/aWbgAkDG1B2Apz0bopAf4TeWu+kyq3cPj5E0ojOuP/lBJHrmrPCEe0DGMPExtFrQD3O",
	"5e4KNkwb5Ya6X8c4o0LIRhRQgTDJiG6DK1rcbJRsRHm9VUBLN0+Ky+fP7PllglVNtTj/FsNrQYutQywI",
	"O+anxY/v3r1fLBdXr15efkj22K1aKKAGXkIlLzzdcehLauiKanhhf2jq76kpth/Y/wAK4xiu+PrHuqQG",
	"Hr6/jZQbDheC8r1hhb5WtLhhYvNCloDiNIxvzPY/YY+PULTeMgOvOnYY7z4O+pvUZnKWS2FA3VI+Ey3x",
	"tfdSmWNfUbBmdygwW6C3+zeSZjazZSW8VrL6B6xeKLrjoDInllV0A++VvNtPIucGoP7gZMVLuj9A1KfY",
	"lip690oYxUBfbODhc7wGKF/QmhbM7B8+g34PykrsmeSomxVnxUfFUUr82oDaX7MKZGMeAJKCtQK9jYfq",
	"LRONgYdgR1emtiS/KEsFWqOw2jHZ820fvk8EMD5g/im2w6955tzZh5YEPwYlMV7MKFaYCM97yVmxx6cy",
	"CuAKuKRlypmjCRthBZIVS3orednbhBVYfzYMV0pW9VxschJ9Bystixswk/zTjnrPxGYCzKEeG+sdTIdE",
	"nYBJ+gmxnhPZqXTBRQkmN0ZCAmP6MROPmTJluAF7Zdklc14whR9N1rGNYWHdkxIMZVyPLLhiy3ipADHi",
	"WiM0DolmKXOQMQOVm+H/K1gvzhf/76wzu8+CzX3WQnXfgkyVou5/uKupKDEzbrcFswVFzBYSU1iT+AaR",
	"ihSSc1prKFErb20xP7El/3zmJj40q24SZCOYSZlY8Bjz4UbkgZeOcRvy7/+ILj2cIWvKSs38K6MZwhMi",
	"1wPCCfc/Z86POihhB7KiPZ/JgYn0dahfRrerBW2KPd7Kkq2DYZz1fVr3r0pGE5XxBTHy/z5nQsDOEWBJ",
	"RMO5dYSENKTYUrFxu/8dDqadGj0th+fMUt7OWTJdc7oncVQO9GPJz0qcnIH7syR8S9VN1nuPsgPhwPhk",
	"ruvYR+JBig8Pd7dcZqNB0YwXfsO0sawGfgDZMbMlWlZAKjDUasDRtiE3F+/PNVcuOsWCSnalpHoRPbL+",
	"WtYc0U4gaFC3VsgrBiUxkgQd6J5Z/iZUlGRNGZ93cLxQeMPEzXjRj1dvoliyJgszsCRwZxQtDJRkrWTV",
	"rrokUvA9WTPOobTn12lqJjZkLZWHK6Bp6Y92PAAd8sZeDdVvpUKOG/MwuSXIlmpSSQUEuPO0M/GLjZAK",
	"yiugpTdK8FlVA0s3t7cPyZrTDdlRTcL7USoHobYklPP2LFFlH5hGCSiJgg1VJQetAwqZIm7KiSALZxXD",
	"aN8tCCXxg2ZRtgKt6QZBoDtp1hzYUSUskeLI2TrX/hrPhqOuHNgdLcDYnHK91nBwp2HUrK06/jC0qjNs",
	"ugEB3mgm3dDjJU93WhNm7U4qds5aRdutm5NYR1uhtDFbqRD6urfCUywE1FmkiCyvKvpnDTVV1J83L+V6",
	"Vux4RikMYILLgxIfI29aXyP3mjf9PdncuPZ90VQrT3kQBZe6UXDtnuATtYNIxSogdpLpSGkYHtz86Skb",
	"NRl2teyB2RSObXCTMy+SzdYa9BaAJzoKZQtAbhbcbHVL52xV+xDdd29tN0Vm4U2D6XyPNvcMeYcVUqCr",
	"XlsJQ2/tc7ueVXmNBqdWHEAWEHTCLAgZAIQGZaB8OXEe/Zh4GqMyiH4zdjorqm6sRzztrYXZNdGGcU7i",
	"S+RPkpfhoVcbQcuUTBdUlVD+G6pHKigZfZmuhm/HjSPJk6lj7AZfb5tqJSjjfwO22ZrpiU0cTLZudDL7",
	"LOWVrjfBiMPFDrBjf95/sNLa7vNm3tnBx+3Cqvzx9IcMAWV4/sD0JKqz9gwzHLz5YTg6oTZUKSxmEB5M",
	"AWPoBlET7tfE4kWfjpA/NHkd5Dn0+4dYDC5/GFCJNHIfojIKOiVI6ETuJsKzE4hBsHWyKjjSPcmRsHyg",
	"vidnR4Nli52wPwszZhK8tmCJtRzv1T7JGgUZnB6HzTl4nAt/1tt020jypNlYAQpiooESL/wvT//ju0OA",
	"TwE8K9LhAJ8V5Yj28KcNKqwZN4DYfX9/9d9viB9G4JbyxllwUhC7VHRTjHQKxiqeilDtvRLvUu1JKZ17",
	"VlFTbGcgdvlFhnG+pJDL5cvkFGERsGNdkMw6b+SGiexS+ez7uPji+TOXXGr/PSoznyTlH1B3kcyM7fEt",
	"VTcPC13BXcGbEso0Jo2HACxrWPahHU9KRZ5Qzp8sSZiGmK3UQHQ6WRcOCTPkleMnXmUGo80JvUfbeNkv",
	"o3EwOeCC/noyhwWjSvwe1mgEx5LZbaN1isleNmQjTbdDD5BzP40k9FayssVbK8u21AqrPdnSWyArAEHW",
	"YIptF6mpgHqX31lKAm5BRREAM8XUDeztkUQo6WJeTphGIUq9Y7SlbnsaSHw5wuNtNamI0jpxiw9iVPIS",
	"1PWWIlLNAeBAiWhxgy1yhPOR5m0TN1Xd5FFLSBUCY4ihOBZTYUqUkxtuWM1hmqPDIDLJ2kHzTsRnA4HC",
	"sJlR2hSyEQcN9trOjW01JiGvQIPJCuhMYZf7mVCfxHc+bxSQREEhb0ENKtye/fWvhyStXwoFVck14zDL",
	"BApjZ1pBjbJmzvus2ggDSK+wa0ki2FYAeM1M6rBuCNUf5JsMYv1s2hfNxUCmXd25d7qGgq3Z0NzAkLu0",
	"RsVFzUK1UX+VEHUEQp0FRmtm5QHqZQnYTaAnQNsSfwrgA87PgBTYOUhrDB7lxC4PGCxLsgKzs9L+uRPr",
	"z5/Z4+HyEkqfwJpZklBtQ77rLzSH05azbJsPLq2Du3v+mfOUkBjwp6pGLLs6kenSOGZeyCpkKnL1d7Fe",
	"L1unpytTTy6DF/LM0GO3oHSw/j91fc6xtjpasYPgOUVqHzUoHro9IjvKgY8fuq7GdZD6s4JYx8djea6N",
	"rF5Y6+XOvAXRIIGlrdwRl0uwBtETTeROeHvnzpAKRGPdUsU2W0MKzoobVCiGdbTGRcETTfwIUgRZk6Qq",
	"0SyFG/33g9P9Mms2uDNWHPE3TNxcFlK89Gbl23DkM+FeSRxqnIUbJiCciRviItzBStwCtRZcL7kcC3wp",
	"39G9XjpTdinFP0vQN0bW9s9KrhgHtOqXU7Fp0GRg2HqtYA0uFhiHLgmIDWd6651jgSLBGlcXnF/oK6Dl",
	"CynWLBa9j8vM9Y1Da5GMIrstiM4dSrOp3ubEA9xun6+lRKMgUhA/YOlRTQu30qoxxrpQ1DgUr6SxpA6a",
	"VBcKAK+5t1AwscHJ6gwWVyjXA741lLtfBN/3iMiXwZTGqBXWfKdKbIPJonF6JgjVBQj7ll3dvtD+V7o6",
	"unZpXSztY3RhXSjJuTV+ESa5FF0t2S2D3ZL44cRslWw22xaaUXwJD0r7tQ6yS1hDhvIHDq78wLmHObZg",
	"638KgBLKiU1+qAHKGewQ1td2uD+ugt6yDbWisbVDOjadUwu7pRaUVPpOFtINhrsZrF6huasROyqM7vx4",
	"VxECUIZyFyGHh9NOJ7KJgwfJNvviSUXayK4dqqRpAZ1IxCkhNpA1fWkw4NM+9/TOd//MjU9AQlEc56j2",
	"Hh8jTIn7UXllvmrWay9lJu4bIbWitICVlDcZIzH/IhPa0JrWuTVrZ7tkjMKmWvHMe2bHjMEnHZyVsONl",
	"a6C3e4mA96BsQWrX7xZD6WLoxAUxyxe5WMbhUoEZ9m82In/QVz6YJZSKCGkOB3/ahBork8QXiisf3Vzl",
	"SxLTkO2D0iys5y53UtFIUnNaQFfD5G6JHcRSJr82qoiKFmTjy9gPzpvLw6WTHp/rOpSk61Vp4xJk6ibj",
	"FOIP1FVPlTv6ArV4Z+F3FTG6IpE0iD6vcCZfATOYa6oQ5rPl6R6nnCbFxGzxxKk2V75mFQnZUm18tL5l",
	"o53buhufQpaU2ExXOYbHZLdlHHx2wKI94aiZwafebnPFUwJ2oM2lgeqaYZO4uqHA0H4sYQYqbF8C7vKI",
	"sg8HiIqFwExbuSYElF1qM3lGuT1Ie/JrAw2O0PmXFQascOSVhXgLC5F63jzF+H9WlWZamzmo6Qh1G/0K",
	"jkDNkUPWiclruslqqGu6yScerZdyOV2KNieBd7IaHKTAdX/ZFqlgqPjosJQR3B/7lMuZN3OKA0acNDqo",
	"TR+SOcdkvBsNylrY/AHK78HX+GkmXzBKEAxvbU9c3ncDJgtl/7C9A6xWcPUNGYXB7bPsvk/XeWAZ8slt",
	"0f9q7wQgrdkDmhKwic4E1jiHolHM7D8UW6iC50Y1Ky4aX8DoogUO8/bXbv2tMfXi/t45Xj65EAzYxQtZ",
	"VdSVMl28v0yCyucLl3CuQdiNnC+ef/P0m29d/sJs3bpnDvizCoxihftl4x02yxzuEFouX/wA5m0YYveu",
	"ayl0rDhf04Ybf6moLRynXfOFs1+00z/3Li/RU6D+VRLn87hpqoqq/eJ8cWUXhNv2mkzVAuBF6E++j8fi",
	"Z/ta2IdOHOgNdi2hnTSBMPWnR9vG2kg8FAWhEcuhIBG25P39fQY7mY3kcWTP/VkJHHxxdC0xRfjSPSc0",
	"5CWpKF1QdGg0j1Hm1vNvh0u/wdH7Xpb7T4airhTrvs+NRjVw/9mOaA9Lh5G+AXP2Gyvvs6fzBwh5876q",
	"QjD8A5h4p5oqWoFLYp7/lJfNzCdBzTZKpvNY15Gibpng/7AO/vnEjNAp9NHxz2DqMAEuOJ9Evz3ldqye",
	"xPsnkQGzilcSHIzsPQQnKfgHkKHp7YQAcN2PpCKN6yAQjvg35NJ7C6y0VpF1W9tyhWWojPBRa8Y5WQGJ",
	"pg6Ky9iB6UQyAu3y9KjiAsVphlAx4nJGyzJPpYuyDGh3fmN8CcF32/brZNgeNRb7lLg+Si4N+MIjKcFN",
	"xPfrBGfWDxhgPr0kPcEkbR8GS9o2qeaNaBeMoXm6xFvcJybO8LL4o3JBBOZBNJlrtwgCd0y7vN40Z/gX",
	"Toz/L81cOR7vyc35vOocXjBNr4SPDOuI8lftkElLpgv9x8kzBc3O0HH3yWdbOiP3buQZ9+sBXIFuCGxJ",
	"4dsFIKu6tkR26qm1W2ov2nLcpLAAi2TlwewVDgvYDQqHMRjdKFeLfJzpN17b3fAOVYKbUDSPLNjeBEdQ",
	"8HTWVY1xbXDF0oWXJLLBs6dLUtE7V+337dOnTzMgxWv4CETPHgaSq9OYwEGbYx6fAlfO0avwWHgun3UC",
	"NFBVbB0y0mp1YO391LZo3bFSuHkYOKtt69BdGV/tia5pYX98ntRLxiLKzAbbMvujuMzHXrry9z1hZe7c",
	"2kGXgwVaJK4p14BlNudekI93TMggLZKDBruTcnns9m8A6n7tv6GbDZS+0sNldAzNHSn/JL/aqV21KMVR",
	"pwTrEHKU2rnQr0OBz4Ty8b0rHqR8wvz/51WQ1zhf9c8fXf/41ORXJfRVCf3BldBdxR/i6GBKh9CuImKe",
	"8gm6ZjJU2L3tYuT9G55JrRKmhK6kND3H84T6uWtDiSloJZM+XvMRVFF1k3fF3VW/tF2YxwdLq1nbkuI+",
	"cuyrY//wFJ55727g+Jz17s/Ga72Lx/PgHU4fbk65G377PMmuwJW+zY+euPuF+1NHryY6Vz5qPCWi6wGs",
	"M6h3yCVd0wKNz5ZxSNaclXNIS3y6HoHDNOE0YpyqnSNQaCdSWvlx1oZOxmLkVbhb8AjCY3DX+VFlRoq2",
	"ITGiGBlSIl7aPkbEz6TICQU6ch0do03mQvqjEqmKQKUonUMt63t+Qr75YKg6Jd+kVfUIbQZ19Y+WrbNg",
	"HMs31gROCNHH6zXdnBKtSWEjgtV+aeOjIdX66N1BjIWNM9A6nXuITpMdOCzXH2nVa7r5jHVMh8Cb2LzF",
	"1JGpl4HoGO3drnJ0yiX4TV9TK19DW19TK1+jWkhU61HzCxPmEiZJj8omHCFPj80i/NGl6tdswddswVe5",
	"+qXJ1d8RMh968hQLmPcl6l0dvhuGitJX7jGhgrx7//YNcd2+kqD4k0PF5P79d3XFF58LDw7QsK2JjYd7",
	"l9Pl3K/BFNuAxSfatVDIqZDXfr5DymN8TfOLqus+Gts4hvJYt8PzgY50NisGmNHhOm8f525c0NWncMSH",
	"3ZIRbzy5avzpK2TnwDa2pFLsTREBucWAHul/7bsJ/U+iDXG5CdJ0Co+sirITP82X1Uh4LokdCqUXzq/f",
	"Xb2NeVkgT+yAJ/EeXJ8ifqpWjuZOvI8/UmXOLH7/7Poy9hAyuAPKsOYJsqq5A3aBXX3rtZbod4NpR91/",
	"vnCUw2wgxASpjk10xiv+fwo2d7wr0dR2Jf+th3FgvB+aeayEhfoyYuFzfbpDKU2foYxKIdWfmWTmifVC",
	"Nol5SNE/GjUiAge4y1JEdY0OcvwiGsr5nlB3McMRJrQEi80NXEeDEYH+y/76WqrYSuGzFOtj3zl4THo4",
	"JES0Wa9Jtdg4RJKpu299onAeuoyl7Xbm0+iC8wGZPidqUOBnYkrHJkZZRLVtjlwr86jlBwm0OOa1kpVv",
	"TjFpCiXWIOY5YnbiSYp9j0/noMgYYneZuz51DCpPlYscdq06JIw/uX78PVfb5uG/Pd2N6J1vnCofu0G+",
	"g3+GMsm4f+1rU3mEYIj23QoOFg/qfiPokQfVNZE+eb+BpF81Gl4fgBo37V/r77pW8m4/5Ri+V/KOQXlZ",
	"+W6N05FyO2hKLJ5AKLo1z2qxechBcbsnLOwNxZO7ec1jAxS8TMD3RzkNS/W+LfOoXOUgcUWz/pK4tTBB",
	"675x6e/aJ6ir008w5FH4AUTZ+1rDidCJfhHiUdGqQVijOunUr8GQ2B1zHl5fUM5XtLjJMnK3bf8ZgPaF",
	"EUejheoBmKPyW2i9ubwBcQIhYODOnG3NMQHkPGL9Ry4mizw1qPANjsXjddRoG8q0XZMjRMO9LXNMF3ot",
	"pHs5Acvlv2zy+M0dDuJueC7ChfbwEYG8QBt01Pmc18VbFyr0B5valXIfSACV38hVGHHCxh/YN08euU7c",
	"7zl+O+YwHuf3sWoGX3dApcvn6lw1o13VEN68cEFabUxvNsqf3m5P4DEmm/wCxM0UMtNmc04dJ23mfvrZ",
	"akNvt2PW97ClnOtpbHdnFvc/3/9vAAAA///1GCDEY5IAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
