// Package commafeed provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.16.2 DO NOT EDIT.
package commafeed

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

const (
	BasicAuthScopes = "basicAuth.Scopes"
)

// Defines values for SettingsExternalLinkIconDisplayMode.
const (
	SettingsExternalLinkIconDisplayModeAlwaysneveronDesktoponMobile SettingsExternalLinkIconDisplayMode = "always,never,on_desktop,on_mobile"
)

// Defines values for SettingsReadingMode.
const (
	Allunread SettingsReadingMode = "all,unread"
)

// Defines values for SettingsReadingOrder.
const (
	Ascdesc SettingsReadingOrder = "asc,desc"
)

// Defines values for SettingsScrollMode.
const (
	AlwaysneverifNeeded SettingsScrollMode = "always,never,if_needed"
)

// Defines values for SettingsStarIconDisplayMode.
const (
	SettingsStarIconDisplayModeAlwaysneveronDesktoponMobile SettingsStarIconDisplayMode = "always,never,on_desktop,on_mobile"
)

// Defines values for GetCategoryEntriesParamsReadType.
const (
	GetCategoryEntriesParamsReadTypeAll    GetCategoryEntriesParamsReadType = "all"
	GetCategoryEntriesParamsReadTypeUnread GetCategoryEntriesParamsReadType = "unread"
)

// Defines values for GetCategoryEntriesParamsOrder.
const (
	GetCategoryEntriesParamsOrderAsc  GetCategoryEntriesParamsOrder = "asc"
	GetCategoryEntriesParamsOrderDesc GetCategoryEntriesParamsOrder = "desc"
)

// Defines values for GetCategoryEntriesAsFeedParamsReadType.
const (
	GetCategoryEntriesAsFeedParamsReadTypeAll    GetCategoryEntriesAsFeedParamsReadType = "all"
	GetCategoryEntriesAsFeedParamsReadTypeUnread GetCategoryEntriesAsFeedParamsReadType = "unread"
)

// Defines values for GetCategoryEntriesAsFeedParamsOrder.
const (
	GetCategoryEntriesAsFeedParamsOrderAsc  GetCategoryEntriesAsFeedParamsOrder = "asc"
	GetCategoryEntriesAsFeedParamsOrderDesc GetCategoryEntriesAsFeedParamsOrder = "desc"
)

// Defines values for GetFeedEntriesParamsReadType.
const (
	GetFeedEntriesParamsReadTypeAll    GetFeedEntriesParamsReadType = "all"
	GetFeedEntriesParamsReadTypeUnread GetFeedEntriesParamsReadType = "unread"
)

// Defines values for GetFeedEntriesParamsOrder.
const (
	GetFeedEntriesParamsOrderAsc  GetFeedEntriesParamsOrder = "asc"
	GetFeedEntriesParamsOrderDesc GetFeedEntriesParamsOrder = "desc"
)

// Defines values for GetFeedEntriesAsFeedParamsReadType.
const (
	GetFeedEntriesAsFeedParamsReadTypeAll    GetFeedEntriesAsFeedParamsReadType = "all"
	GetFeedEntriesAsFeedParamsReadTypeUnread GetFeedEntriesAsFeedParamsReadType = "unread"
)

// Defines values for GetFeedEntriesAsFeedParamsOrder.
const (
	GetFeedEntriesAsFeedParamsOrderAsc  GetFeedEntriesAsFeedParamsOrder = "asc"
	GetFeedEntriesAsFeedParamsOrderDesc GetFeedEntriesAsFeedParamsOrder = "desc"
)

// AddCategoryRequest Add Category Request
type AddCategoryRequest struct {
	// Name name
	Name string `json:"name"`

	// ParentId parent category id, if any
	ParentId *string `json:"parentId,omitempty"`
}

// AdminSaveUserRequest Save User information
type AdminSaveUserRequest struct {
	// Admin user is admin
	Admin bool `json:"admin"`

	// Email user email, if any
	Email *string `json:"email,omitempty"`

	// Enabled account status
	Enabled bool `json:"enabled"`

	// Id user id
	Id *int64 `json:"id,omitempty"`

	// Name user name
	Name string `json:"name"`

	// Password user password
	Password *string `json:"password,omitempty"`
}

// Category Entry details
type Category struct {
	// Children category children categories
	Children []Category `json:"children"`

	// Expanded whether the category is expanded or collapsed
	Expanded bool `json:"expanded"`

	// Feeds category feeds
	Feeds []Subscription `json:"feeds"`

	// Id category id
	Id string `json:"id"`

	// Name category id
	Name string `json:"name"`

	// ParentId parent category id
	ParentId *string `json:"parentId,omitempty"`

	// ParentName parent category name
	ParentName *string `json:"parentName,omitempty"`

	// Position position of the category in the list
	Position int32 `json:"position"`
}

// CategoryModificationRequest Category modification request
type CategoryModificationRequest struct {
	// Id id
	Id int64 `json:"id"`

	// Name new name, null if not changed
	Name *string `json:"name,omitempty"`

	// ParentId new parent category id
	ParentId *string `json:"parentId,omitempty"`

	// Position new display position, null if not changed
	Position *int32 `json:"position,omitempty"`
}

// CollapseRequest Mark Request
type CollapseRequest struct {
	// Collapse collapse
	Collapse bool `json:"collapse"`

	// Id category id
	Id int64 `json:"id"`
}

// Entries List of entries with some metadata
type Entries struct {
	// Entries list of entries
	Entries []Entry `json:"entries"`

	// ErrorCount times the server tried to refresh the feed and failed
	ErrorCount int32 `json:"errorCount"`

	// FeedLink URL of the website, extracted from the feed, only filled if querying for feed entries, not category entries
	FeedLink *string `json:"feedLink,omitempty"`

	// HasMore if the query has more elements
	HasMore bool `json:"hasMore"`

	// IgnoredReadStatus if true, the unread flag was ignored in the request, all entries are returned regardless of their read status
	IgnoredReadStatus bool `json:"ignoredReadStatus"`

	// Limit the requested limit
	Limit *int32 `json:"limit,omitempty"`

	// Message error or warning message
	Message *string `json:"message,omitempty"`

	// Name name of the feed or the category requested
	Name string `json:"name"`

	// Offset the requested offset
	Offset *int32 `json:"offset,omitempty"`

	// Timestamp list generation timestamp
	Timestamp int64 `json:"timestamp"`
}

// Entry Entry details
type Entry struct {
	// Author entry author
	Author *string `json:"author,omitempty"`

	// Categories comma-separated list of categories
	Categories *string `json:"categories,omitempty"`

	// Content entry content
	Content string `json:"content"`

	// Date entry publication date
	Date string `json:"date"`

	// EnclosureType entry enclosure mime type, if any
	EnclosureType *string `json:"enclosureType,omitempty"`

	// EnclosureUrl entry enclosure url, if any
	EnclosureUrl *string `json:"enclosureUrl,omitempty"`

	// FeedId feed id
	FeedId string `json:"feedId"`

	// FeedLink this entry's website url
	FeedLink string `json:"feedLink"`

	// FeedName feed name
	FeedName string `json:"feedName"`

	// FeedUrl this entry's feed url
	FeedUrl string `json:"feedUrl"`

	// Guid entry guid
	Guid string `json:"guid"`

	// IconUrl The favicon url to use for this feed
	IconUrl string `json:"iconUrl"`

	// Id entry id
	Id string `json:"id"`

	// InsertedDate entry insertion date in the database
	InsertedDate string `json:"insertedDate"`

	// Markable whether the entry is still markable (old entry statuses are discarded)
	Markable bool `json:"markable"`

	// MediaDescription entry media description, if any
	MediaDescription *string `json:"mediaDescription,omitempty"`

	// MediaThumbnailHeight entry media thumbnail height, if any
	MediaThumbnailHeight *int32 `json:"mediaThumbnailHeight,omitempty"`

	// MediaThumbnailUrl entry media thumbnail url, if any
	MediaThumbnailUrl *string `json:"mediaThumbnailUrl,omitempty"`

	// MediaThumbnailWidth entry media thumbnail width, if any
	MediaThumbnailWidth *int32 `json:"mediaThumbnailWidth,omitempty"`

	// Read read status
	Read bool `json:"read"`

	// Rtl whether entry content and title are rtl
	Rtl bool `json:"rtl"`

	// Starred starred status
	Starred bool `json:"starred"`

	// Tags tags
	Tags []string `json:"tags"`

	// Title entry title
	Title string `json:"title"`

	// Url entry url
	Url string `json:"url"`
}

// FeedInfo Feed details
type FeedInfo struct {
	// Title title
	Title string `json:"title"`

	// Url url
	Url string `json:"url"`
}

// FeedInfoRequest Feed information request
type FeedInfoRequest struct {
	// Url feed url
	Url string `json:"url"`
}

// FeedModificationRequest Feed modification request
type FeedModificationRequest struct {
	// CategoryId new parent category id
	CategoryId *string `json:"categoryId,omitempty"`

	// Filter JEXL string evaluated on new entries to mark them as read if they do not match
	Filter *string `json:"filter,omitempty"`

	// Id id
	Id int64 `json:"id"`

	// Name new name, null if not changed
	Name *string `json:"name,omitempty"`

	// Position new display position, null if not changed
	Position *int32 `json:"position,omitempty"`
}

// IDRequest defines model for IDRequest.
type IDRequest struct {
	Id int64 `json:"id"`
}

// MarkRequest Mark Request
type MarkRequest struct {
	// ExcludedSubscriptions if marking a category or 'all', exclude those subscriptions from the marking
	ExcludedSubscriptions *[]int64 `json:"excludedSubscriptions,omitempty"`

	// Id entry id, category id, 'all' or 'starred'
	Id string `json:"id"`

	// InsertedBefore pass the timestamp you got from the entry list to avoid marking entries that may have been fetched in the mean time and never displayed
	InsertedBefore *int64 `json:"insertedBefore,omitempty"`

	// Keywords only mark read if a feed has these keywords in the title or rss content
	Keywords *string `json:"keywords,omitempty"`

	// OlderThan mark only entries older than this
	OlderThan *int64 `json:"olderThan,omitempty"`

	// Read mark as read or unread
	Read bool `json:"read"`
}

// MultipleMarkRequest Multiple Mark Request
type MultipleMarkRequest struct {
	// Requests list of mark requests
	Requests []MarkRequest `json:"requests"`
}

// PasswordResetRequest defines model for PasswordResetRequest.
type PasswordResetRequest struct {
	// Email email address for password recovery
	Email string `json:"email"`
}

// ProfileModificationRequest Profile modification request
type ProfileModificationRequest struct {
	// CurrentPassword current user password, required to change profile data
	CurrentPassword string `json:"currentPassword"`

	// Email changes email of the user, if specified
	Email *string `json:"email,omitempty"`

	// NewApiKey generate a new api key
	NewApiKey *bool `json:"newApiKey,omitempty"`

	// NewPassword changes password of the user, if specified
	NewPassword *string `json:"newPassword,omitempty"`
}

// RegistrationRequest defines model for RegistrationRequest.
type RegistrationRequest struct {
	// Email email address for password recovery
	Email string `json:"email"`

	// Name username, between 3 and 32 characters
	Name string `json:"name"`

	// Password password, minimum 6 characters
	Password string `json:"password"`
}

// ServerInfo Server infos
type ServerInfo struct {
	AllowRegistrations    bool    `json:"allowRegistrations"`
	Announcement          *string `json:"announcement,omitempty"`
	DemoAccountEnabled    bool    `json:"demoAccountEnabled"`
	GitCommit             string  `json:"gitCommit"`
	GoogleAnalyticsCode   *string `json:"googleAnalyticsCode,omitempty"`
	SmtpEnabled           bool    `json:"smtpEnabled"`
	TreeReloadInterval    int64   `json:"treeReloadInterval"`
	Version               string  `json:"version"`
	WebsocketEnabled      bool    `json:"websocketEnabled"`
	WebsocketPingInterval int64   `json:"websocketPingInterval"`
}

// Settings User settings
type Settings struct {
	// CustomContextMenu show commafeed's own context menu on right click
	CustomContextMenu bool `json:"customContextMenu"`

	// CustomCss user's custom css for the website
	CustomCss *string `json:"customCss,omitempty"`

	// CustomJs user's custom js for the website
	CustomJs *string `json:"customJs,omitempty"`

	// ExternalLinkIconDisplayMode whether to show the external link icon in the header of entries
	ExternalLinkIconDisplayMode SettingsExternalLinkIconDisplayMode `json:"externalLinkIconDisplayMode"`

	// Language user's preferred language, english if none
	Language string `json:"language"`

	// MarkAllAsReadConfirmation ask for confirmation when marking all entries as read
	MarkAllAsReadConfirmation bool `json:"markAllAsReadConfirmation"`

	// MobileFooter on mobile, show action buttons at the bottom of the screen
	MobileFooter bool `json:"mobileFooter"`

	// ReadingMode user reads all entries or unread entries only
	ReadingMode SettingsReadingMode `json:"readingMode"`

	// ReadingOrder user reads entries in ascending or descending order
	ReadingOrder SettingsReadingOrder `json:"readingOrder"`

	// ScrollMarks In expanded view, scroll through entries mark them as read
	ScrollMarks bool `json:"scrollMarks"`

	// ScrollMode whether to scroll to the selected entry
	ScrollMode SettingsScrollMode `json:"scrollMode"`

	// ScrollSpeed user's preferred scroll speed when navigating between entries
	ScrollSpeed int32 `json:"scrollSpeed"`

	// SharingSettings User sharing settings
	SharingSettings SharingSettings `json:"sharingSettings"`

	// ShowRead user wants category and feeds with no unread entries shown
	ShowRead bool `json:"showRead"`

	// StarIconDisplayMode whether to show the star icon in the header of entries
	StarIconDisplayMode SettingsStarIconDisplayMode `json:"starIconDisplayMode"`

	// UnreadCountFavicon show unread count in the favicon
	UnreadCountFavicon bool `json:"unreadCountFavicon"`

	// UnreadCountTitle show unread count in the title
	UnreadCountTitle bool `json:"unreadCountTitle"`
}

// SettingsExternalLinkIconDisplayMode whether to show the external link icon in the header of entries
type SettingsExternalLinkIconDisplayMode string

// SettingsReadingMode user reads all entries or unread entries only
type SettingsReadingMode string

// SettingsReadingOrder user reads entries in ascending or descending order
type SettingsReadingOrder string

// SettingsScrollMode whether to scroll to the selected entry
type SettingsScrollMode string

// SettingsStarIconDisplayMode whether to show the star icon in the header of entries
type SettingsStarIconDisplayMode string

// SharingSettings User sharing settings
type SharingSettings struct {
	Buffer     bool `json:"buffer"`
	Email      bool `json:"email"`
	Facebook   bool `json:"facebook"`
	Gmail      bool `json:"gmail"`
	Instapaper bool `json:"instapaper"`
	Pocket     bool `json:"pocket"`
	Tumblr     bool `json:"tumblr"`
	Twitter    bool `json:"twitter"`
}

// StarRequest Star Request
type StarRequest struct {
	// FeedId feed id
	FeedId int64 `json:"feedId"`

	// Id id
	Id string `json:"id"`

	// Starred starred or not
	Starred bool `json:"starred"`
}

// SubscribeRequest Subscription request
type SubscribeRequest struct {
	// CategoryId id of the user category to place the feed in
	CategoryId *string `json:"categoryId,omitempty"`

	// Title name of the feed for the user
	Title string `json:"title"`

	// Url url of the feed
	Url string `json:"url"`
}

// Subscription User information
type Subscription struct {
	// CategoryId category id
	CategoryId *string `json:"categoryId,omitempty"`

	// ErrorCount error count
	ErrorCount int32 `json:"errorCount"`

	// FeedLink this subscription's website url
	FeedLink string `json:"feedLink"`

	// FeedUrl this subscription's feed url
	FeedUrl string `json:"feedUrl"`

	// Filter JEXL string evaluated on new entries to mark them as read if they do not match
	Filter *string `json:"filter,omitempty"`

	// IconUrl The favicon url to use for this feed
	IconUrl string `json:"iconUrl"`

	// Id subscription id
	Id int64 `json:"id"`

	// LastRefresh last time the feed was refreshed
	LastRefresh *string `json:"lastRefresh,omitempty"`

	// Message error message while fetching the feed
	Message *string `json:"message,omitempty"`

	// Name subscription name
	Name string `json:"name"`

	// NewestItemTime date of the newest item
	NewestItemTime *string `json:"newestItemTime,omitempty"`

	// NextRefresh next time the feed refresh is planned, null if refresh is already queued
	NextRefresh *string `json:"nextRefresh,omitempty"`

	// Position position of the subscription's in the list
	Position *int32 `json:"position,omitempty"`

	// Unread unread count
	Unread int64 `json:"unread"`
}

// TagRequest Tag Request
type TagRequest struct {
	// EntryId entry id
	EntryId int64 `json:"entryId"`

	// Tags tags
	Tags []string `json:"tags"`
}

// UnreadCount Unread count
type UnreadCount struct {
	FeedId         *int64   `json:"feedId,omitempty"`
	NewestItemTime *float32 `json:"newestItemTime,omitempty"`
	UnreadCount    *int64   `json:"unreadCount,omitempty"`
}

// UserModel User information
type UserModel struct {
	// Admin user is admin
	Admin bool `json:"admin"`

	// ApiKey api key
	ApiKey *string `json:"apiKey,omitempty"`

	// Created account creation date
	Created *float32 `json:"created,omitempty"`

	// Email user email, if any
	Email *string `json:"email,omitempty"`

	// Enabled account status
	Enabled bool `json:"enabled"`

	// Id user id
	Id int64 `json:"id"`

	// LastLogin last login date
	LastLogin *float32 `json:"lastLogin,omitempty"`

	// Name user name
	Name string `json:"name"`

	// Password user password, never returned by the api
	Password *string `json:"password,omitempty"`
}

// GetCategoryEntriesParams defines parameters for GetCategoryEntries.
type GetCategoryEntriesParams struct {
	// Id id of the category, 'all' or 'starred'
	Id string `form:"id" json:"id"`

	// ReadType all entries or only unread ones
	ReadType GetCategoryEntriesParamsReadType `form:"readType" json:"readType"`

	// NewerThan only entries newer than this
	NewerThan *int64 `form:"newerThan,omitempty" json:"newerThan,omitempty"`

	// Offset offset for paging
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit limit for paging, default 20, maximum 1000
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order ordering
	Order *GetCategoryEntriesParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Keywords search for keywords in either the title or the content of the entries, separated by spaces, 3 characters minimum
	Keywords *string `form:"keywords,omitempty" json:"keywords,omitempty"`

	// ExcludedSubscriptionIds comma-separated list of excluded subscription ids
	ExcludedSubscriptionIds *string `form:"excludedSubscriptionIds,omitempty" json:"excludedSubscriptionIds,omitempty"`

	// Tag keep only entries tagged with this tag
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`
}

// GetCategoryEntriesParamsReadType defines parameters for GetCategoryEntries.
type GetCategoryEntriesParamsReadType string

// GetCategoryEntriesParamsOrder defines parameters for GetCategoryEntries.
type GetCategoryEntriesParamsOrder string

// GetCategoryEntriesAsFeedParams defines parameters for GetCategoryEntriesAsFeed.
type GetCategoryEntriesAsFeedParams struct {
	// Id id of the category, 'all' or 'starred'
	Id string `form:"id" json:"id"`

	// ReadType all entries or only unread ones
	ReadType GetCategoryEntriesAsFeedParamsReadType `form:"readType" json:"readType"`

	// NewerThan only entries newer than this
	NewerThan *int64 `form:"newerThan,omitempty" json:"newerThan,omitempty"`

	// Offset offset for paging
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit limit for paging, default 20, maximum 1000
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order date ordering
	Order *GetCategoryEntriesAsFeedParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Keywords search for keywords in either the title or the content of the entries, separated by spaces, 3 characters minimum
	Keywords *string `form:"keywords,omitempty" json:"keywords,omitempty"`

	// ExcludedSubscriptionIds comma-separated list of excluded subscription ids
	ExcludedSubscriptionIds *string `form:"excludedSubscriptionIds,omitempty" json:"excludedSubscriptionIds,omitempty"`

	// Tag keep only entries tagged with this tag
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`
}

// GetCategoryEntriesAsFeedParamsReadType defines parameters for GetCategoryEntriesAsFeed.
type GetCategoryEntriesAsFeedParamsReadType string

// GetCategoryEntriesAsFeedParamsOrder defines parameters for GetCategoryEntriesAsFeed.
type GetCategoryEntriesAsFeedParamsOrder string

// GetFeedEntriesParams defines parameters for GetFeedEntries.
type GetFeedEntriesParams struct {
	// Id id of the feed
	Id string `form:"id" json:"id"`

	// ReadType all entries or only unread ones
	ReadType GetFeedEntriesParamsReadType `form:"readType" json:"readType"`

	// NewerThan only entries newer than this
	NewerThan *int64 `form:"newerThan,omitempty" json:"newerThan,omitempty"`

	// Offset offset for paging
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit limit for paging, default 20, maximum 1000
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order ordering
	Order *GetFeedEntriesParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Keywords search for keywords in either the title or the content of the entries, separated by spaces, 3 characters minimum
	Keywords *string `form:"keywords,omitempty" json:"keywords,omitempty"`
}

// GetFeedEntriesParamsReadType defines parameters for GetFeedEntries.
type GetFeedEntriesParamsReadType string

// GetFeedEntriesParamsOrder defines parameters for GetFeedEntries.
type GetFeedEntriesParamsOrder string

// GetFeedEntriesAsFeedParams defines parameters for GetFeedEntriesAsFeed.
type GetFeedEntriesAsFeedParams struct {
	// Id id of the feed
	Id string `form:"id" json:"id"`

	// ReadType all entries or only unread ones
	ReadType GetFeedEntriesAsFeedParamsReadType `form:"readType" json:"readType"`

	// NewerThan only entries newer than this
	NewerThan *int64 `form:"newerThan,omitempty" json:"newerThan,omitempty"`

	// Offset offset for paging
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit limit for paging, default 20, maximum 1000
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order date ordering
	Order *GetFeedEntriesAsFeedParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Keywords search for keywords in either the title or the content of the entries, separated by spaces, 3 characters minimum
	Keywords *string `form:"keywords,omitempty" json:"keywords,omitempty"`
}

// GetFeedEntriesAsFeedParamsReadType defines parameters for GetFeedEntriesAsFeed.
type GetFeedEntriesAsFeedParamsReadType string

// GetFeedEntriesAsFeedParamsOrder defines parameters for GetFeedEntriesAsFeed.
type GetFeedEntriesAsFeedParamsOrder string

// ImportOpmlMultipartBody defines parameters for ImportOpml.
type ImportOpmlMultipartBody = string

// SubscribeFromUrlParams defines parameters for SubscribeFromUrl.
type SubscribeFromUrlParams struct {
	// Url feed url
	Url string `form:"url" json:"url"`
}

// GetProxiedImageParams defines parameters for GetProxiedImage.
type GetProxiedImageParams struct {
	// U image url
	U string `form:"u" json:"u"`
}

// PasswordRecoveryCallbackParams defines parameters for PasswordRecoveryCallback.
type PasswordRecoveryCallbackParams struct {
	Email string `form:"email" json:"email"`
	Token string `form:"token" json:"token"`
}

// AdminDeleteUserJSONRequestBody defines body for AdminDeleteUser for application/json ContentType.
type AdminDeleteUserJSONRequestBody = IDRequest

// AdminSaveUserJSONRequestBody defines body for AdminSaveUser for application/json ContentType.
type AdminSaveUserJSONRequestBody = AdminSaveUserRequest

// AddCategoryJSONRequestBody defines body for AddCategory for application/json ContentType.
type AddCategoryJSONRequestBody = AddCategoryRequest

// CollapseCategoryJSONRequestBody defines body for CollapseCategory for application/json ContentType.
type CollapseCategoryJSONRequestBody = CollapseRequest

// DeleteCategoryJSONRequestBody defines body for DeleteCategory for application/json ContentType.
type DeleteCategoryJSONRequestBody = IDRequest

// MarkCategoryEntriesJSONRequestBody defines body for MarkCategoryEntries for application/json ContentType.
type MarkCategoryEntriesJSONRequestBody = MarkRequest

// ModifyCategoryJSONRequestBody defines body for ModifyCategory for application/json ContentType.
type ModifyCategoryJSONRequestBody = CategoryModificationRequest

// MarkEntryJSONRequestBody defines body for MarkEntry for application/json ContentType.
type MarkEntryJSONRequestBody = MarkRequest

// MarkEntriesJSONRequestBody defines body for MarkEntries for application/json ContentType.
type MarkEntriesJSONRequestBody = MultipleMarkRequest

// StarEntryJSONRequestBody defines body for StarEntry for application/json ContentType.
type StarEntryJSONRequestBody = StarRequest

// TagEntryJSONRequestBody defines body for TagEntry for application/json ContentType.
type TagEntryJSONRequestBody = TagRequest

// FetchFeedJSONRequestBody defines body for FetchFeed for application/json ContentType.
type FetchFeedJSONRequestBody = FeedInfoRequest

// ImportOpmlMultipartRequestBody defines body for ImportOpml for multipart/form-data ContentType.
type ImportOpmlMultipartRequestBody = ImportOpmlMultipartBody

// MarkFeedEntriesJSONRequestBody defines body for MarkFeedEntries for application/json ContentType.
type MarkFeedEntriesJSONRequestBody = MarkRequest

// ModifyFeedJSONRequestBody defines body for ModifyFeed for application/json ContentType.
type ModifyFeedJSONRequestBody = FeedModificationRequest

// QueueForRefreshJSONRequestBody defines body for QueueForRefresh for application/json ContentType.
type QueueForRefreshJSONRequestBody = IDRequest

// SubscribeJSONRequestBody defines body for Subscribe for application/json ContentType.
type SubscribeJSONRequestBody = SubscribeRequest

// UnsubscribeJSONRequestBody defines body for Unsubscribe for application/json ContentType.
type UnsubscribeJSONRequestBody = IDRequest

// SendPasswordResetJSONRequestBody defines body for SendPasswordReset for application/json ContentType.
type SendPasswordResetJSONRequestBody = PasswordResetRequest

// SaveUserProfileJSONRequestBody defines body for SaveUserProfile for application/json ContentType.
type SaveUserProfileJSONRequestBody = ProfileModificationRequest

// RegisterUserJSONRequestBody defines body for RegisterUser for application/json ContentType.
type RegisterUserJSONRequestBody = RegistrationRequest

// SaveUserSettingsJSONRequestBody defines body for SaveUserSettings for application/json ContentType.
type SaveUserSettingsJSONRequestBody = Settings

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetMetrics request
	GetMetrics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AdminDeleteUserWithBody request with any body
	AdminDeleteUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AdminDeleteUser(ctx context.Context, body AdminDeleteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AdminGetUser request
	AdminGetUser(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AdminGetUsers request
	AdminGetUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AdminSaveUserWithBody request with any body
	AdminSaveUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AdminSaveUser(ctx context.Context, body AdminSaveUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddCategoryWithBody request with any body
	AddCategoryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddCategory(ctx context.Context, body AddCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CollapseCategoryWithBody request with any body
	CollapseCategoryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CollapseCategory(ctx context.Context, body CollapseCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCategoryWithBody request with any body
	DeleteCategoryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteCategory(ctx context.Context, body DeleteCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCategoryEntries request
	GetCategoryEntries(ctx context.Context, params *GetCategoryEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCategoryEntriesAsFeed request
	GetCategoryEntriesAsFeed(ctx context.Context, params *GetCategoryEntriesAsFeedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRootCategory request
	GetRootCategory(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MarkCategoryEntriesWithBody request with any body
	MarkCategoryEntriesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MarkCategoryEntries(ctx context.Context, body MarkCategoryEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModifyCategoryWithBody request with any body
	ModifyCategoryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ModifyCategory(ctx context.Context, body ModifyCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUnreadCount request
	GetUnreadCount(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MarkEntryWithBody request with any body
	MarkEntryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MarkEntry(ctx context.Context, body MarkEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MarkEntriesWithBody request with any body
	MarkEntriesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MarkEntries(ctx context.Context, body MarkEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StarEntryWithBody request with any body
	StarEntryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StarEntry(ctx context.Context, body StarEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TagEntryWithBody request with any body
	TagEntryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TagEntry(ctx context.Context, body TagEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTags request
	GetTags(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFeedEntries request
	GetFeedEntries(ctx context.Context, params *GetFeedEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFeedEntriesAsFeed request
	GetFeedEntriesAsFeed(ctx context.Context, params *GetFeedEntriesAsFeedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportOpml request
	ExportOpml(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFeedFavicon request
	GetFeedFavicon(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FetchFeedWithBody request with any body
	FetchFeedWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FetchFeed(ctx context.Context, body FetchFeedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFeed request
	GetFeed(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportOpmlWithBody request with any body
	ImportOpmlWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MarkFeedEntriesWithBody request with any body
	MarkFeedEntriesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MarkFeedEntries(ctx context.Context, body MarkFeedEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModifyFeedWithBody request with any body
	ModifyFeedWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ModifyFeed(ctx context.Context, body ModifyFeedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QueueForRefreshWithBody request with any body
	QueueForRefreshWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	QueueForRefresh(ctx context.Context, body QueueForRefreshJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QueueAllForRefresh request
	QueueAllForRefresh(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SubscribeFromUrl request
	SubscribeFromUrl(ctx context.Context, params *SubscribeFromUrlParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SubscribeWithBody request with any body
	SubscribeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Subscribe(ctx context.Context, body SubscribeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnsubscribeWithBody request with any body
	UnsubscribeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Unsubscribe(ctx context.Context, body UnsubscribeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServerInfos request
	GetServerInfos(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProxiedImage request
	GetProxiedImage(ctx context.Context, params *GetProxiedImageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendPasswordResetWithBody request with any body
	SendPasswordResetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendPasswordReset(ctx context.Context, body SendPasswordResetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasswordRecoveryCallback request
	PasswordRecoveryCallback(ctx context.Context, params *PasswordRecoveryCallbackParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserProfile request
	GetUserProfile(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SaveUserProfileWithBody request with any body
	SaveUserProfileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SaveUserProfile(ctx context.Context, body SaveUserProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegisterUserWithBody request with any body
	RegisterUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RegisterUser(ctx context.Context, body RegisterUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserSettings request
	GetUserSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SaveUserSettingsWithBody request with any body
	SaveUserSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SaveUserSettings(ctx context.Context, body SaveUserSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetMetrics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMetricsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AdminDeleteUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAdminDeleteUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AdminDeleteUser(ctx context.Context, body AdminDeleteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAdminDeleteUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AdminGetUser(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAdminGetUserRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AdminGetUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAdminGetUsersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AdminSaveUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAdminSaveUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AdminSaveUser(ctx context.Context, body AdminSaveUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAdminSaveUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddCategoryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddCategoryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddCategory(ctx context.Context, body AddCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddCategoryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CollapseCategoryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCollapseCategoryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CollapseCategory(ctx context.Context, body CollapseCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCollapseCategoryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCategoryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCategoryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCategory(ctx context.Context, body DeleteCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCategoryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCategoryEntries(ctx context.Context, params *GetCategoryEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCategoryEntriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCategoryEntriesAsFeed(ctx context.Context, params *GetCategoryEntriesAsFeedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCategoryEntriesAsFeedRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRootCategory(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRootCategoryRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkCategoryEntriesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkCategoryEntriesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkCategoryEntries(ctx context.Context, body MarkCategoryEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkCategoryEntriesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyCategoryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyCategoryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyCategory(ctx context.Context, body ModifyCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyCategoryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUnreadCount(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUnreadCountRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkEntryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkEntryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkEntry(ctx context.Context, body MarkEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkEntryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkEntriesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkEntriesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkEntries(ctx context.Context, body MarkEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkEntriesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StarEntryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStarEntryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StarEntry(ctx context.Context, body StarEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStarEntryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TagEntryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagEntryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TagEntry(ctx context.Context, body TagEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagEntryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTags(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTagsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFeedEntries(ctx context.Context, params *GetFeedEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFeedEntriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFeedEntriesAsFeed(ctx context.Context, params *GetFeedEntriesAsFeedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFeedEntriesAsFeedRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportOpml(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportOpmlRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFeedFavicon(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFeedFaviconRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FetchFeedWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFetchFeedRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FetchFeed(ctx context.Context, body FetchFeedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFetchFeedRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFeed(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFeedRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportOpmlWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportOpmlRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkFeedEntriesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkFeedEntriesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkFeedEntries(ctx context.Context, body MarkFeedEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkFeedEntriesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyFeedWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyFeedRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyFeed(ctx context.Context, body ModifyFeedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyFeedRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueueForRefreshWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueueForRefreshRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueueForRefresh(ctx context.Context, body QueueForRefreshJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueueForRefreshRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueueAllForRefresh(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueueAllForRefreshRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubscribeFromUrl(ctx context.Context, params *SubscribeFromUrlParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubscribeFromUrlRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubscribeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubscribeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Subscribe(ctx context.Context, body SubscribeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubscribeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnsubscribeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnsubscribeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Unsubscribe(ctx context.Context, body UnsubscribeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnsubscribeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServerInfos(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServerInfosRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProxiedImage(ctx context.Context, params *GetProxiedImageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProxiedImageRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendPasswordResetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendPasswordResetRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendPasswordReset(ctx context.Context, body SendPasswordResetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendPasswordResetRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasswordRecoveryCallback(ctx context.Context, params *PasswordRecoveryCallbackParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasswordRecoveryCallbackRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserProfile(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserProfileRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveUserProfileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveUserProfileRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveUserProfile(ctx context.Context, body SaveUserProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveUserProfileRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterUser(ctx context.Context, body RegisterUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserSettingsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveUserSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveUserSettingsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveUserSettings(ctx context.Context, body SaveUserSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveUserSettingsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetMetricsRequest generates requests for GetMetrics
func NewGetMetricsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/admin/metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAdminDeleteUserRequest calls the generic AdminDeleteUser builder with application/json body
func NewAdminDeleteUserRequest(server string, body AdminDeleteUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAdminDeleteUserRequestWithBody(server, "application/json", bodyReader)
}

// NewAdminDeleteUserRequestWithBody generates requests for AdminDeleteUser with any type of body
func NewAdminDeleteUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/admin/user/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAdminGetUserRequest generates requests for AdminGetUser
func NewAdminGetUserRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/admin/user/get/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAdminGetUsersRequest generates requests for AdminGetUsers
func NewAdminGetUsersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/admin/user/getAll")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAdminSaveUserRequest calls the generic AdminSaveUser builder with application/json body
func NewAdminSaveUserRequest(server string, body AdminSaveUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAdminSaveUserRequestWithBody(server, "application/json", bodyReader)
}

// NewAdminSaveUserRequestWithBody generates requests for AdminSaveUser with any type of body
func NewAdminSaveUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/admin/user/save")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddCategoryRequest calls the generic AddCategory builder with application/json body
func NewAddCategoryRequest(server string, body AddCategoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddCategoryRequestWithBody(server, "application/json", bodyReader)
}

// NewAddCategoryRequestWithBody generates requests for AddCategory with any type of body
func NewAddCategoryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/category/add")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCollapseCategoryRequest calls the generic CollapseCategory builder with application/json body
func NewCollapseCategoryRequest(server string, body CollapseCategoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCollapseCategoryRequestWithBody(server, "application/json", bodyReader)
}

// NewCollapseCategoryRequestWithBody generates requests for CollapseCategory with any type of body
func NewCollapseCategoryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/category/collapse")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCategoryRequest calls the generic DeleteCategory builder with application/json body
func NewDeleteCategoryRequest(server string, body DeleteCategoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteCategoryRequestWithBody(server, "application/json", bodyReader)
}

// NewDeleteCategoryRequestWithBody generates requests for DeleteCategory with any type of body
func NewDeleteCategoryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/category/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCategoryEntriesRequest generates requests for GetCategoryEntries
func NewGetCategoryEntriesRequest(server string, params *GetCategoryEntriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/category/entries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "readType", runtime.ParamLocationQuery, params.ReadType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.NewerThan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newerThan", runtime.ParamLocationQuery, *params.NewerThan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Keywords != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keywords", runtime.ParamLocationQuery, *params.Keywords); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludedSubscriptionIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludedSubscriptionIds", runtime.ParamLocationQuery, *params.ExcludedSubscriptionIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCategoryEntriesAsFeedRequest generates requests for GetCategoryEntriesAsFeed
func NewGetCategoryEntriesAsFeedRequest(server string, params *GetCategoryEntriesAsFeedParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/category/entriesAsFeed")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "readType", runtime.ParamLocationQuery, params.ReadType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.NewerThan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newerThan", runtime.ParamLocationQuery, *params.NewerThan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Keywords != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keywords", runtime.ParamLocationQuery, *params.Keywords); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludedSubscriptionIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludedSubscriptionIds", runtime.ParamLocationQuery, *params.ExcludedSubscriptionIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRootCategoryRequest generates requests for GetRootCategory
func NewGetRootCategoryRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/category/get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMarkCategoryEntriesRequest calls the generic MarkCategoryEntries builder with application/json body
func NewMarkCategoryEntriesRequest(server string, body MarkCategoryEntriesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMarkCategoryEntriesRequestWithBody(server, "application/json", bodyReader)
}

// NewMarkCategoryEntriesRequestWithBody generates requests for MarkCategoryEntries with any type of body
func NewMarkCategoryEntriesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/category/mark")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewModifyCategoryRequest calls the generic ModifyCategory builder with application/json body
func NewModifyCategoryRequest(server string, body ModifyCategoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewModifyCategoryRequestWithBody(server, "application/json", bodyReader)
}

// NewModifyCategoryRequestWithBody generates requests for ModifyCategory with any type of body
func NewModifyCategoryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/category/modify")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUnreadCountRequest generates requests for GetUnreadCount
func NewGetUnreadCountRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/category/unreadCount")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMarkEntryRequest calls the generic MarkEntry builder with application/json body
func NewMarkEntryRequest(server string, body MarkEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMarkEntryRequestWithBody(server, "application/json", bodyReader)
}

// NewMarkEntryRequestWithBody generates requests for MarkEntry with any type of body
func NewMarkEntryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/entry/mark")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMarkEntriesRequest calls the generic MarkEntries builder with application/json body
func NewMarkEntriesRequest(server string, body MarkEntriesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMarkEntriesRequestWithBody(server, "application/json", bodyReader)
}

// NewMarkEntriesRequestWithBody generates requests for MarkEntries with any type of body
func NewMarkEntriesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/entry/markMultiple")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStarEntryRequest calls the generic StarEntry builder with application/json body
func NewStarEntryRequest(server string, body StarEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStarEntryRequestWithBody(server, "application/json", bodyReader)
}

// NewStarEntryRequestWithBody generates requests for StarEntry with any type of body
func NewStarEntryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/entry/star")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTagEntryRequest calls the generic TagEntry builder with application/json body
func NewTagEntryRequest(server string, body TagEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTagEntryRequestWithBody(server, "application/json", bodyReader)
}

// NewTagEntryRequestWithBody generates requests for TagEntry with any type of body
func NewTagEntryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/entry/tag")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTagsRequest generates requests for GetTags
func NewGetTagsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/entry/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFeedEntriesRequest generates requests for GetFeedEntries
func NewGetFeedEntriesRequest(server string, params *GetFeedEntriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/feed/entries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "readType", runtime.ParamLocationQuery, params.ReadType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.NewerThan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newerThan", runtime.ParamLocationQuery, *params.NewerThan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Keywords != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keywords", runtime.ParamLocationQuery, *params.Keywords); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFeedEntriesAsFeedRequest generates requests for GetFeedEntriesAsFeed
func NewGetFeedEntriesAsFeedRequest(server string, params *GetFeedEntriesAsFeedParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/feed/entriesAsFeed")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "readType", runtime.ParamLocationQuery, params.ReadType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.NewerThan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newerThan", runtime.ParamLocationQuery, *params.NewerThan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Keywords != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keywords", runtime.ParamLocationQuery, *params.Keywords); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExportOpmlRequest generates requests for ExportOpml
func NewExportOpmlRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/feed/export")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFeedFaviconRequest generates requests for GetFeedFavicon
func NewGetFeedFaviconRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/feed/favicon/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFetchFeedRequest calls the generic FetchFeed builder with application/json body
func NewFetchFeedRequest(server string, body FetchFeedJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFetchFeedRequestWithBody(server, "application/json", bodyReader)
}

// NewFetchFeedRequestWithBody generates requests for FetchFeed with any type of body
func NewFetchFeedRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/feed/fetch")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFeedRequest generates requests for GetFeed
func NewGetFeedRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/feed/get/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewImportOpmlRequestWithBody generates requests for ImportOpml with any type of body
func NewImportOpmlRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/feed/import")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMarkFeedEntriesRequest calls the generic MarkFeedEntries builder with application/json body
func NewMarkFeedEntriesRequest(server string, body MarkFeedEntriesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMarkFeedEntriesRequestWithBody(server, "application/json", bodyReader)
}

// NewMarkFeedEntriesRequestWithBody generates requests for MarkFeedEntries with any type of body
func NewMarkFeedEntriesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/feed/mark")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewModifyFeedRequest calls the generic ModifyFeed builder with application/json body
func NewModifyFeedRequest(server string, body ModifyFeedJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewModifyFeedRequestWithBody(server, "application/json", bodyReader)
}

// NewModifyFeedRequestWithBody generates requests for ModifyFeed with any type of body
func NewModifyFeedRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/feed/modify")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewQueueForRefreshRequest calls the generic QueueForRefresh builder with application/json body
func NewQueueForRefreshRequest(server string, body QueueForRefreshJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewQueueForRefreshRequestWithBody(server, "application/json", bodyReader)
}

// NewQueueForRefreshRequestWithBody generates requests for QueueForRefresh with any type of body
func NewQueueForRefreshRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/feed/refresh")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewQueueAllForRefreshRequest generates requests for QueueAllForRefresh
func NewQueueAllForRefreshRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/feed/refreshAll")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSubscribeFromUrlRequest generates requests for SubscribeFromUrl
func NewSubscribeFromUrlRequest(server string, params *SubscribeFromUrlParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/feed/subscribe")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "url", runtime.ParamLocationQuery, params.Url); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSubscribeRequest calls the generic Subscribe builder with application/json body
func NewSubscribeRequest(server string, body SubscribeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSubscribeRequestWithBody(server, "application/json", bodyReader)
}

// NewSubscribeRequestWithBody generates requests for Subscribe with any type of body
func NewSubscribeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/feed/subscribe")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnsubscribeRequest calls the generic Unsubscribe builder with application/json body
func NewUnsubscribeRequest(server string, body UnsubscribeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnsubscribeRequestWithBody(server, "application/json", bodyReader)
}

// NewUnsubscribeRequestWithBody generates requests for Unsubscribe with any type of body
func NewUnsubscribeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/feed/unsubscribe")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetServerInfosRequest generates requests for GetServerInfos
func NewGetServerInfosRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/server/get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProxiedImageRequest generates requests for GetProxiedImage
func NewGetProxiedImageRequest(server string, params *GetProxiedImageParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/server/proxy")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "u", runtime.ParamLocationQuery, params.U); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendPasswordResetRequest calls the generic SendPasswordReset builder with application/json body
func NewSendPasswordResetRequest(server string, body SendPasswordResetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendPasswordResetRequestWithBody(server, "application/json", bodyReader)
}

// NewSendPasswordResetRequestWithBody generates requests for SendPasswordReset with any type of body
func NewSendPasswordResetRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/user/passwordReset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPasswordRecoveryCallbackRequest generates requests for PasswordRecoveryCallback
func NewPasswordRecoveryCallbackRequest(server string, params *PasswordRecoveryCallbackParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/user/passwordResetCallback")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "email", runtime.ParamLocationQuery, params.Email); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, params.Token); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserProfileRequest generates requests for GetUserProfile
func NewGetUserProfileRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/user/profile")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSaveUserProfileRequest calls the generic SaveUserProfile builder with application/json body
func NewSaveUserProfileRequest(server string, body SaveUserProfileJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSaveUserProfileRequestWithBody(server, "application/json", bodyReader)
}

// NewSaveUserProfileRequestWithBody generates requests for SaveUserProfile with any type of body
func NewSaveUserProfileRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/user/profile")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserRequest generates requests for DeleteUser
func NewDeleteUserRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/user/profile/deleteAccount")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRegisterUserRequest calls the generic RegisterUser builder with application/json body
func NewRegisterUserRequest(server string, body RegisterUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRegisterUserRequestWithBody(server, "application/json", bodyReader)
}

// NewRegisterUserRequestWithBody generates requests for RegisterUser with any type of body
func NewRegisterUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/user/register")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserSettingsRequest generates requests for GetUserSettings
func NewGetUserSettingsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/user/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSaveUserSettingsRequest calls the generic SaveUserSettings builder with application/json body
func NewSaveUserSettingsRequest(server string, body SaveUserSettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSaveUserSettingsRequestWithBody(server, "application/json", bodyReader)
}

// NewSaveUserSettingsRequestWithBody generates requests for SaveUserSettings with any type of body
func NewSaveUserSettingsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rest/user/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetMetricsWithResponse request
	GetMetricsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMetricsResponse, error)

	// AdminDeleteUserWithBodyWithResponse request with any body
	AdminDeleteUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AdminDeleteUserResponse, error)

	AdminDeleteUserWithResponse(ctx context.Context, body AdminDeleteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AdminDeleteUserResponse, error)

	// AdminGetUserWithResponse request
	AdminGetUserWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*AdminGetUserResponse, error)

	// AdminGetUsersWithResponse request
	AdminGetUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AdminGetUsersResponse, error)

	// AdminSaveUserWithBodyWithResponse request with any body
	AdminSaveUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AdminSaveUserResponse, error)

	AdminSaveUserWithResponse(ctx context.Context, body AdminSaveUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AdminSaveUserResponse, error)

	// AddCategoryWithBodyWithResponse request with any body
	AddCategoryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddCategoryResponse, error)

	AddCategoryWithResponse(ctx context.Context, body AddCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*AddCategoryResponse, error)

	// CollapseCategoryWithBodyWithResponse request with any body
	CollapseCategoryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CollapseCategoryResponse, error)

	CollapseCategoryWithResponse(ctx context.Context, body CollapseCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*CollapseCategoryResponse, error)

	// DeleteCategoryWithBodyWithResponse request with any body
	DeleteCategoryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteCategoryResponse, error)

	DeleteCategoryWithResponse(ctx context.Context, body DeleteCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteCategoryResponse, error)

	// GetCategoryEntriesWithResponse request
	GetCategoryEntriesWithResponse(ctx context.Context, params *GetCategoryEntriesParams, reqEditors ...RequestEditorFn) (*GetCategoryEntriesResponse, error)

	// GetCategoryEntriesAsFeedWithResponse request
	GetCategoryEntriesAsFeedWithResponse(ctx context.Context, params *GetCategoryEntriesAsFeedParams, reqEditors ...RequestEditorFn) (*GetCategoryEntriesAsFeedResponse, error)

	// GetRootCategoryWithResponse request
	GetRootCategoryWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRootCategoryResponse, error)

	// MarkCategoryEntriesWithBodyWithResponse request with any body
	MarkCategoryEntriesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarkCategoryEntriesResponse, error)

	MarkCategoryEntriesWithResponse(ctx context.Context, body MarkCategoryEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*MarkCategoryEntriesResponse, error)

	// ModifyCategoryWithBodyWithResponse request with any body
	ModifyCategoryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyCategoryResponse, error)

	ModifyCategoryWithResponse(ctx context.Context, body ModifyCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyCategoryResponse, error)

	// GetUnreadCountWithResponse request
	GetUnreadCountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUnreadCountResponse, error)

	// MarkEntryWithBodyWithResponse request with any body
	MarkEntryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarkEntryResponse, error)

	MarkEntryWithResponse(ctx context.Context, body MarkEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*MarkEntryResponse, error)

	// MarkEntriesWithBodyWithResponse request with any body
	MarkEntriesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarkEntriesResponse, error)

	MarkEntriesWithResponse(ctx context.Context, body MarkEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*MarkEntriesResponse, error)

	// StarEntryWithBodyWithResponse request with any body
	StarEntryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StarEntryResponse, error)

	StarEntryWithResponse(ctx context.Context, body StarEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*StarEntryResponse, error)

	// TagEntryWithBodyWithResponse request with any body
	TagEntryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TagEntryResponse, error)

	TagEntryWithResponse(ctx context.Context, body TagEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*TagEntryResponse, error)

	// GetTagsWithResponse request
	GetTagsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTagsResponse, error)

	// GetFeedEntriesWithResponse request
	GetFeedEntriesWithResponse(ctx context.Context, params *GetFeedEntriesParams, reqEditors ...RequestEditorFn) (*GetFeedEntriesResponse, error)

	// GetFeedEntriesAsFeedWithResponse request
	GetFeedEntriesAsFeedWithResponse(ctx context.Context, params *GetFeedEntriesAsFeedParams, reqEditors ...RequestEditorFn) (*GetFeedEntriesAsFeedResponse, error)

	// ExportOpmlWithResponse request
	ExportOpmlWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ExportOpmlResponse, error)

	// GetFeedFaviconWithResponse request
	GetFeedFaviconWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetFeedFaviconResponse, error)

	// FetchFeedWithBodyWithResponse request with any body
	FetchFeedWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FetchFeedResponse, error)

	FetchFeedWithResponse(ctx context.Context, body FetchFeedJSONRequestBody, reqEditors ...RequestEditorFn) (*FetchFeedResponse, error)

	// GetFeedWithResponse request
	GetFeedWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetFeedResponse, error)

	// ImportOpmlWithBodyWithResponse request with any body
	ImportOpmlWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportOpmlResponse, error)

	// MarkFeedEntriesWithBodyWithResponse request with any body
	MarkFeedEntriesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarkFeedEntriesResponse, error)

	MarkFeedEntriesWithResponse(ctx context.Context, body MarkFeedEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*MarkFeedEntriesResponse, error)

	// ModifyFeedWithBodyWithResponse request with any body
	ModifyFeedWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyFeedResponse, error)

	ModifyFeedWithResponse(ctx context.Context, body ModifyFeedJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyFeedResponse, error)

	// QueueForRefreshWithBodyWithResponse request with any body
	QueueForRefreshWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueueForRefreshResponse, error)

	QueueForRefreshWithResponse(ctx context.Context, body QueueForRefreshJSONRequestBody, reqEditors ...RequestEditorFn) (*QueueForRefreshResponse, error)

	// QueueAllForRefreshWithResponse request
	QueueAllForRefreshWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*QueueAllForRefreshResponse, error)

	// SubscribeFromUrlWithResponse request
	SubscribeFromUrlWithResponse(ctx context.Context, params *SubscribeFromUrlParams, reqEditors ...RequestEditorFn) (*SubscribeFromUrlResponse, error)

	// SubscribeWithBodyWithResponse request with any body
	SubscribeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubscribeResponse, error)

	SubscribeWithResponse(ctx context.Context, body SubscribeJSONRequestBody, reqEditors ...RequestEditorFn) (*SubscribeResponse, error)

	// UnsubscribeWithBodyWithResponse request with any body
	UnsubscribeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnsubscribeResponse, error)

	UnsubscribeWithResponse(ctx context.Context, body UnsubscribeJSONRequestBody, reqEditors ...RequestEditorFn) (*UnsubscribeResponse, error)

	// GetServerInfosWithResponse request
	GetServerInfosWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetServerInfosResponse, error)

	// GetProxiedImageWithResponse request
	GetProxiedImageWithResponse(ctx context.Context, params *GetProxiedImageParams, reqEditors ...RequestEditorFn) (*GetProxiedImageResponse, error)

	// SendPasswordResetWithBodyWithResponse request with any body
	SendPasswordResetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendPasswordResetResponse, error)

	SendPasswordResetWithResponse(ctx context.Context, body SendPasswordResetJSONRequestBody, reqEditors ...RequestEditorFn) (*SendPasswordResetResponse, error)

	// PasswordRecoveryCallbackWithResponse request
	PasswordRecoveryCallbackWithResponse(ctx context.Context, params *PasswordRecoveryCallbackParams, reqEditors ...RequestEditorFn) (*PasswordRecoveryCallbackResponse, error)

	// GetUserProfileWithResponse request
	GetUserProfileWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserProfileResponse, error)

	// SaveUserProfileWithBodyWithResponse request with any body
	SaveUserProfileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveUserProfileResponse, error)

	SaveUserProfileWithResponse(ctx context.Context, body SaveUserProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*SaveUserProfileResponse, error)

	// DeleteUserWithResponse request
	DeleteUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error)

	// RegisterUserWithBodyWithResponse request with any body
	RegisterUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterUserResponse, error)

	RegisterUserWithResponse(ctx context.Context, body RegisterUserJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterUserResponse, error)

	// GetUserSettingsWithResponse request
	GetUserSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserSettingsResponse, error)

	// SaveUserSettingsWithBodyWithResponse request with any body
	SaveUserSettingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveUserSettingsResponse, error)

	SaveUserSettingsWithResponse(ctx context.Context, body SaveUserSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*SaveUserSettingsResponse, error)
}

type GetMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AdminDeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AdminDeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AdminDeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AdminGetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *UserModel
}

// Status returns HTTPResponse.Status
func (r AdminGetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AdminGetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AdminGetUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *[]UserModel
}

// Status returns HTTPResponse.Status
func (r AdminGetUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AdminGetUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AdminSaveUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AdminSaveUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AdminSaveUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *int64
}

// Status returns HTTPResponse.Status
func (r AddCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CollapseCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CollapseCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CollapseCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCategoryEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Entries
}

// Status returns HTTPResponse.Status
func (r GetCategoryEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCategoryEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCategoryEntriesAsFeedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetCategoryEntriesAsFeedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCategoryEntriesAsFeedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRootCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Category
}

// Status returns HTTPResponse.Status
func (r GetRootCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRootCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MarkCategoryEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MarkCategoryEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MarkCategoryEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModifyCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ModifyCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModifyCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUnreadCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *[]UnreadCount
}

// Status returns HTTPResponse.Status
func (r GetUnreadCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUnreadCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MarkEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MarkEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MarkEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MarkEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MarkEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MarkEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StarEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StarEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StarEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TagEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TagEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TagEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFeedEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Entries
}

// Status returns HTTPResponse.Status
func (r GetFeedEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFeedEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFeedEntriesAsFeedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetFeedEntriesAsFeedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFeedEntriesAsFeedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportOpmlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ExportOpmlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportOpmlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFeedFaviconResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetFeedFaviconResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFeedFaviconResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FetchFeedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *FeedInfo
}

// Status returns HTTPResponse.Status
func (r FetchFeedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchFeedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFeedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Subscription
}

// Status returns HTTPResponse.Status
func (r GetFeedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFeedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportOpmlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ImportOpmlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportOpmlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MarkFeedEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MarkFeedEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MarkFeedEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModifyFeedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ModifyFeedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModifyFeedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueueForRefreshResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r QueueForRefreshResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueueForRefreshResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueueAllForRefreshResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r QueueAllForRefreshResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueueAllForRefreshResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SubscribeFromUrlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SubscribeFromUrlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubscribeFromUrlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SubscribeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *int64
}

// Status returns HTTPResponse.Status
func (r SubscribeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubscribeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnsubscribeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnsubscribeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnsubscribeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServerInfosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ServerInfo
}

// Status returns HTTPResponse.Status
func (r GetServerInfosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServerInfosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProxiedImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetProxiedImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProxiedImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendPasswordResetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SendPasswordResetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendPasswordResetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasswordRecoveryCallbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PasswordRecoveryCallbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasswordRecoveryCallbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *UserModel
}

// Status returns HTTPResponse.Status
func (r GetUserProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SaveUserProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SaveUserProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SaveUserProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegisterUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RegisterUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegisterUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Settings
}

// Status returns HTTPResponse.Status
func (r GetUserSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SaveUserSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SaveUserSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SaveUserSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetMetricsWithResponse request returning *GetMetricsResponse
func (c *ClientWithResponses) GetMetricsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMetricsResponse, error) {
	rsp, err := c.GetMetrics(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMetricsResponse(rsp)
}

// AdminDeleteUserWithBodyWithResponse request with arbitrary body returning *AdminDeleteUserResponse
func (c *ClientWithResponses) AdminDeleteUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AdminDeleteUserResponse, error) {
	rsp, err := c.AdminDeleteUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAdminDeleteUserResponse(rsp)
}

func (c *ClientWithResponses) AdminDeleteUserWithResponse(ctx context.Context, body AdminDeleteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AdminDeleteUserResponse, error) {
	rsp, err := c.AdminDeleteUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAdminDeleteUserResponse(rsp)
}

// AdminGetUserWithResponse request returning *AdminGetUserResponse
func (c *ClientWithResponses) AdminGetUserWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*AdminGetUserResponse, error) {
	rsp, err := c.AdminGetUser(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAdminGetUserResponse(rsp)
}

// AdminGetUsersWithResponse request returning *AdminGetUsersResponse
func (c *ClientWithResponses) AdminGetUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AdminGetUsersResponse, error) {
	rsp, err := c.AdminGetUsers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAdminGetUsersResponse(rsp)
}

// AdminSaveUserWithBodyWithResponse request with arbitrary body returning *AdminSaveUserResponse
func (c *ClientWithResponses) AdminSaveUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AdminSaveUserResponse, error) {
	rsp, err := c.AdminSaveUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAdminSaveUserResponse(rsp)
}

func (c *ClientWithResponses) AdminSaveUserWithResponse(ctx context.Context, body AdminSaveUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AdminSaveUserResponse, error) {
	rsp, err := c.AdminSaveUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAdminSaveUserResponse(rsp)
}

// AddCategoryWithBodyWithResponse request with arbitrary body returning *AddCategoryResponse
func (c *ClientWithResponses) AddCategoryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddCategoryResponse, error) {
	rsp, err := c.AddCategoryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddCategoryResponse(rsp)
}

func (c *ClientWithResponses) AddCategoryWithResponse(ctx context.Context, body AddCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*AddCategoryResponse, error) {
	rsp, err := c.AddCategory(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddCategoryResponse(rsp)
}

// CollapseCategoryWithBodyWithResponse request with arbitrary body returning *CollapseCategoryResponse
func (c *ClientWithResponses) CollapseCategoryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CollapseCategoryResponse, error) {
	rsp, err := c.CollapseCategoryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCollapseCategoryResponse(rsp)
}

func (c *ClientWithResponses) CollapseCategoryWithResponse(ctx context.Context, body CollapseCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*CollapseCategoryResponse, error) {
	rsp, err := c.CollapseCategory(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCollapseCategoryResponse(rsp)
}

// DeleteCategoryWithBodyWithResponse request with arbitrary body returning *DeleteCategoryResponse
func (c *ClientWithResponses) DeleteCategoryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteCategoryResponse, error) {
	rsp, err := c.DeleteCategoryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCategoryResponse(rsp)
}

func (c *ClientWithResponses) DeleteCategoryWithResponse(ctx context.Context, body DeleteCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteCategoryResponse, error) {
	rsp, err := c.DeleteCategory(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCategoryResponse(rsp)
}

// GetCategoryEntriesWithResponse request returning *GetCategoryEntriesResponse
func (c *ClientWithResponses) GetCategoryEntriesWithResponse(ctx context.Context, params *GetCategoryEntriesParams, reqEditors ...RequestEditorFn) (*GetCategoryEntriesResponse, error) {
	rsp, err := c.GetCategoryEntries(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCategoryEntriesResponse(rsp)
}

// GetCategoryEntriesAsFeedWithResponse request returning *GetCategoryEntriesAsFeedResponse
func (c *ClientWithResponses) GetCategoryEntriesAsFeedWithResponse(ctx context.Context, params *GetCategoryEntriesAsFeedParams, reqEditors ...RequestEditorFn) (*GetCategoryEntriesAsFeedResponse, error) {
	rsp, err := c.GetCategoryEntriesAsFeed(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCategoryEntriesAsFeedResponse(rsp)
}

// GetRootCategoryWithResponse request returning *GetRootCategoryResponse
func (c *ClientWithResponses) GetRootCategoryWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRootCategoryResponse, error) {
	rsp, err := c.GetRootCategory(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRootCategoryResponse(rsp)
}

// MarkCategoryEntriesWithBodyWithResponse request with arbitrary body returning *MarkCategoryEntriesResponse
func (c *ClientWithResponses) MarkCategoryEntriesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarkCategoryEntriesResponse, error) {
	rsp, err := c.MarkCategoryEntriesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkCategoryEntriesResponse(rsp)
}

func (c *ClientWithResponses) MarkCategoryEntriesWithResponse(ctx context.Context, body MarkCategoryEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*MarkCategoryEntriesResponse, error) {
	rsp, err := c.MarkCategoryEntries(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkCategoryEntriesResponse(rsp)
}

// ModifyCategoryWithBodyWithResponse request with arbitrary body returning *ModifyCategoryResponse
func (c *ClientWithResponses) ModifyCategoryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyCategoryResponse, error) {
	rsp, err := c.ModifyCategoryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyCategoryResponse(rsp)
}

func (c *ClientWithResponses) ModifyCategoryWithResponse(ctx context.Context, body ModifyCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyCategoryResponse, error) {
	rsp, err := c.ModifyCategory(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyCategoryResponse(rsp)
}

// GetUnreadCountWithResponse request returning *GetUnreadCountResponse
func (c *ClientWithResponses) GetUnreadCountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUnreadCountResponse, error) {
	rsp, err := c.GetUnreadCount(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUnreadCountResponse(rsp)
}

// MarkEntryWithBodyWithResponse request with arbitrary body returning *MarkEntryResponse
func (c *ClientWithResponses) MarkEntryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarkEntryResponse, error) {
	rsp, err := c.MarkEntryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkEntryResponse(rsp)
}

func (c *ClientWithResponses) MarkEntryWithResponse(ctx context.Context, body MarkEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*MarkEntryResponse, error) {
	rsp, err := c.MarkEntry(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkEntryResponse(rsp)
}

// MarkEntriesWithBodyWithResponse request with arbitrary body returning *MarkEntriesResponse
func (c *ClientWithResponses) MarkEntriesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarkEntriesResponse, error) {
	rsp, err := c.MarkEntriesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkEntriesResponse(rsp)
}

func (c *ClientWithResponses) MarkEntriesWithResponse(ctx context.Context, body MarkEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*MarkEntriesResponse, error) {
	rsp, err := c.MarkEntries(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkEntriesResponse(rsp)
}

// StarEntryWithBodyWithResponse request with arbitrary body returning *StarEntryResponse
func (c *ClientWithResponses) StarEntryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StarEntryResponse, error) {
	rsp, err := c.StarEntryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStarEntryResponse(rsp)
}

func (c *ClientWithResponses) StarEntryWithResponse(ctx context.Context, body StarEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*StarEntryResponse, error) {
	rsp, err := c.StarEntry(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStarEntryResponse(rsp)
}

// TagEntryWithBodyWithResponse request with arbitrary body returning *TagEntryResponse
func (c *ClientWithResponses) TagEntryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TagEntryResponse, error) {
	rsp, err := c.TagEntryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagEntryResponse(rsp)
}

func (c *ClientWithResponses) TagEntryWithResponse(ctx context.Context, body TagEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*TagEntryResponse, error) {
	rsp, err := c.TagEntry(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagEntryResponse(rsp)
}

// GetTagsWithResponse request returning *GetTagsResponse
func (c *ClientWithResponses) GetTagsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTagsResponse, error) {
	rsp, err := c.GetTags(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTagsResponse(rsp)
}

// GetFeedEntriesWithResponse request returning *GetFeedEntriesResponse
func (c *ClientWithResponses) GetFeedEntriesWithResponse(ctx context.Context, params *GetFeedEntriesParams, reqEditors ...RequestEditorFn) (*GetFeedEntriesResponse, error) {
	rsp, err := c.GetFeedEntries(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFeedEntriesResponse(rsp)
}

// GetFeedEntriesAsFeedWithResponse request returning *GetFeedEntriesAsFeedResponse
func (c *ClientWithResponses) GetFeedEntriesAsFeedWithResponse(ctx context.Context, params *GetFeedEntriesAsFeedParams, reqEditors ...RequestEditorFn) (*GetFeedEntriesAsFeedResponse, error) {
	rsp, err := c.GetFeedEntriesAsFeed(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFeedEntriesAsFeedResponse(rsp)
}

// ExportOpmlWithResponse request returning *ExportOpmlResponse
func (c *ClientWithResponses) ExportOpmlWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ExportOpmlResponse, error) {
	rsp, err := c.ExportOpml(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportOpmlResponse(rsp)
}

// GetFeedFaviconWithResponse request returning *GetFeedFaviconResponse
func (c *ClientWithResponses) GetFeedFaviconWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetFeedFaviconResponse, error) {
	rsp, err := c.GetFeedFavicon(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFeedFaviconResponse(rsp)
}

// FetchFeedWithBodyWithResponse request with arbitrary body returning *FetchFeedResponse
func (c *ClientWithResponses) FetchFeedWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FetchFeedResponse, error) {
	rsp, err := c.FetchFeedWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFetchFeedResponse(rsp)
}

func (c *ClientWithResponses) FetchFeedWithResponse(ctx context.Context, body FetchFeedJSONRequestBody, reqEditors ...RequestEditorFn) (*FetchFeedResponse, error) {
	rsp, err := c.FetchFeed(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFetchFeedResponse(rsp)
}

// GetFeedWithResponse request returning *GetFeedResponse
func (c *ClientWithResponses) GetFeedWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetFeedResponse, error) {
	rsp, err := c.GetFeed(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFeedResponse(rsp)
}

// ImportOpmlWithBodyWithResponse request with arbitrary body returning *ImportOpmlResponse
func (c *ClientWithResponses) ImportOpmlWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportOpmlResponse, error) {
	rsp, err := c.ImportOpmlWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportOpmlResponse(rsp)
}

// MarkFeedEntriesWithBodyWithResponse request with arbitrary body returning *MarkFeedEntriesResponse
func (c *ClientWithResponses) MarkFeedEntriesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarkFeedEntriesResponse, error) {
	rsp, err := c.MarkFeedEntriesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkFeedEntriesResponse(rsp)
}

func (c *ClientWithResponses) MarkFeedEntriesWithResponse(ctx context.Context, body MarkFeedEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*MarkFeedEntriesResponse, error) {
	rsp, err := c.MarkFeedEntries(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkFeedEntriesResponse(rsp)
}

// ModifyFeedWithBodyWithResponse request with arbitrary body returning *ModifyFeedResponse
func (c *ClientWithResponses) ModifyFeedWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyFeedResponse, error) {
	rsp, err := c.ModifyFeedWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyFeedResponse(rsp)
}

func (c *ClientWithResponses) ModifyFeedWithResponse(ctx context.Context, body ModifyFeedJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyFeedResponse, error) {
	rsp, err := c.ModifyFeed(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyFeedResponse(rsp)
}

// QueueForRefreshWithBodyWithResponse request with arbitrary body returning *QueueForRefreshResponse
func (c *ClientWithResponses) QueueForRefreshWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueueForRefreshResponse, error) {
	rsp, err := c.QueueForRefreshWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueueForRefreshResponse(rsp)
}

func (c *ClientWithResponses) QueueForRefreshWithResponse(ctx context.Context, body QueueForRefreshJSONRequestBody, reqEditors ...RequestEditorFn) (*QueueForRefreshResponse, error) {
	rsp, err := c.QueueForRefresh(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueueForRefreshResponse(rsp)
}

// QueueAllForRefreshWithResponse request returning *QueueAllForRefreshResponse
func (c *ClientWithResponses) QueueAllForRefreshWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*QueueAllForRefreshResponse, error) {
	rsp, err := c.QueueAllForRefresh(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueueAllForRefreshResponse(rsp)
}

// SubscribeFromUrlWithResponse request returning *SubscribeFromUrlResponse
func (c *ClientWithResponses) SubscribeFromUrlWithResponse(ctx context.Context, params *SubscribeFromUrlParams, reqEditors ...RequestEditorFn) (*SubscribeFromUrlResponse, error) {
	rsp, err := c.SubscribeFromUrl(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubscribeFromUrlResponse(rsp)
}

// SubscribeWithBodyWithResponse request with arbitrary body returning *SubscribeResponse
func (c *ClientWithResponses) SubscribeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubscribeResponse, error) {
	rsp, err := c.SubscribeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubscribeResponse(rsp)
}

func (c *ClientWithResponses) SubscribeWithResponse(ctx context.Context, body SubscribeJSONRequestBody, reqEditors ...RequestEditorFn) (*SubscribeResponse, error) {
	rsp, err := c.Subscribe(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubscribeResponse(rsp)
}

// UnsubscribeWithBodyWithResponse request with arbitrary body returning *UnsubscribeResponse
func (c *ClientWithResponses) UnsubscribeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnsubscribeResponse, error) {
	rsp, err := c.UnsubscribeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnsubscribeResponse(rsp)
}

func (c *ClientWithResponses) UnsubscribeWithResponse(ctx context.Context, body UnsubscribeJSONRequestBody, reqEditors ...RequestEditorFn) (*UnsubscribeResponse, error) {
	rsp, err := c.Unsubscribe(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnsubscribeResponse(rsp)
}

// GetServerInfosWithResponse request returning *GetServerInfosResponse
func (c *ClientWithResponses) GetServerInfosWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetServerInfosResponse, error) {
	rsp, err := c.GetServerInfos(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServerInfosResponse(rsp)
}

// GetProxiedImageWithResponse request returning *GetProxiedImageResponse
func (c *ClientWithResponses) GetProxiedImageWithResponse(ctx context.Context, params *GetProxiedImageParams, reqEditors ...RequestEditorFn) (*GetProxiedImageResponse, error) {
	rsp, err := c.GetProxiedImage(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProxiedImageResponse(rsp)
}

// SendPasswordResetWithBodyWithResponse request with arbitrary body returning *SendPasswordResetResponse
func (c *ClientWithResponses) SendPasswordResetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendPasswordResetResponse, error) {
	rsp, err := c.SendPasswordResetWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendPasswordResetResponse(rsp)
}

func (c *ClientWithResponses) SendPasswordResetWithResponse(ctx context.Context, body SendPasswordResetJSONRequestBody, reqEditors ...RequestEditorFn) (*SendPasswordResetResponse, error) {
	rsp, err := c.SendPasswordReset(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendPasswordResetResponse(rsp)
}

// PasswordRecoveryCallbackWithResponse request returning *PasswordRecoveryCallbackResponse
func (c *ClientWithResponses) PasswordRecoveryCallbackWithResponse(ctx context.Context, params *PasswordRecoveryCallbackParams, reqEditors ...RequestEditorFn) (*PasswordRecoveryCallbackResponse, error) {
	rsp, err := c.PasswordRecoveryCallback(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasswordRecoveryCallbackResponse(rsp)
}

// GetUserProfileWithResponse request returning *GetUserProfileResponse
func (c *ClientWithResponses) GetUserProfileWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserProfileResponse, error) {
	rsp, err := c.GetUserProfile(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserProfileResponse(rsp)
}

// SaveUserProfileWithBodyWithResponse request with arbitrary body returning *SaveUserProfileResponse
func (c *ClientWithResponses) SaveUserProfileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveUserProfileResponse, error) {
	rsp, err := c.SaveUserProfileWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveUserProfileResponse(rsp)
}

func (c *ClientWithResponses) SaveUserProfileWithResponse(ctx context.Context, body SaveUserProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*SaveUserProfileResponse, error) {
	rsp, err := c.SaveUserProfile(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveUserProfileResponse(rsp)
}

// DeleteUserWithResponse request returning *DeleteUserResponse
func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error) {
	rsp, err := c.DeleteUser(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResponse(rsp)
}

// RegisterUserWithBodyWithResponse request with arbitrary body returning *RegisterUserResponse
func (c *ClientWithResponses) RegisterUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterUserResponse, error) {
	rsp, err := c.RegisterUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterUserResponse(rsp)
}

func (c *ClientWithResponses) RegisterUserWithResponse(ctx context.Context, body RegisterUserJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterUserResponse, error) {
	rsp, err := c.RegisterUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterUserResponse(rsp)
}

// GetUserSettingsWithResponse request returning *GetUserSettingsResponse
func (c *ClientWithResponses) GetUserSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserSettingsResponse, error) {
	rsp, err := c.GetUserSettings(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserSettingsResponse(rsp)
}

// SaveUserSettingsWithBodyWithResponse request with arbitrary body returning *SaveUserSettingsResponse
func (c *ClientWithResponses) SaveUserSettingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveUserSettingsResponse, error) {
	rsp, err := c.SaveUserSettingsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveUserSettingsResponse(rsp)
}

func (c *ClientWithResponses) SaveUserSettingsWithResponse(ctx context.Context, body SaveUserSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*SaveUserSettingsResponse, error) {
	rsp, err := c.SaveUserSettings(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveUserSettingsResponse(rsp)
}

// ParseGetMetricsResponse parses an HTTP response from a GetMetricsWithResponse call
func ParseGetMetricsResponse(rsp *http.Response) (*GetMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAdminDeleteUserResponse parses an HTTP response from a AdminDeleteUserWithResponse call
func ParseAdminDeleteUserResponse(rsp *http.Response) (*AdminDeleteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AdminDeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAdminGetUserResponse parses an HTTP response from a AdminGetUserWithResponse call
func ParseAdminGetUserResponse(rsp *http.Response) (*AdminGetUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AdminGetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UserModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAdminGetUsersResponse parses an HTTP response from a AdminGetUsersWithResponse call
func ParseAdminGetUsersResponse(rsp *http.Response) (*AdminGetUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AdminGetUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest []UserModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAdminSaveUserResponse parses an HTTP response from a AdminSaveUserWithResponse call
func ParseAdminSaveUserResponse(rsp *http.Response) (*AdminSaveUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AdminSaveUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAddCategoryResponse parses an HTTP response from a AddCategoryWithResponse call
func ParseAddCategoryResponse(rsp *http.Response) (*AddCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest int64
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCollapseCategoryResponse parses an HTTP response from a CollapseCategoryWithResponse call
func ParseCollapseCategoryResponse(rsp *http.Response) (*CollapseCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CollapseCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteCategoryResponse parses an HTTP response from a DeleteCategoryWithResponse call
func ParseDeleteCategoryResponse(rsp *http.Response) (*DeleteCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCategoryEntriesResponse parses an HTTP response from a GetCategoryEntriesWithResponse call
func ParseGetCategoryEntriesResponse(rsp *http.Response) (*GetCategoryEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCategoryEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Entries
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCategoryEntriesAsFeedResponse parses an HTTP response from a GetCategoryEntriesAsFeedWithResponse call
func ParseGetCategoryEntriesAsFeedResponse(rsp *http.Response) (*GetCategoryEntriesAsFeedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCategoryEntriesAsFeedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetRootCategoryResponse parses an HTTP response from a GetRootCategoryWithResponse call
func ParseGetRootCategoryResponse(rsp *http.Response) (*GetRootCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRootCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Category
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMarkCategoryEntriesResponse parses an HTTP response from a MarkCategoryEntriesWithResponse call
func ParseMarkCategoryEntriesResponse(rsp *http.Response) (*MarkCategoryEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MarkCategoryEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseModifyCategoryResponse parses an HTTP response from a ModifyCategoryWithResponse call
func ParseModifyCategoryResponse(rsp *http.Response) (*ModifyCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModifyCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUnreadCountResponse parses an HTTP response from a GetUnreadCountWithResponse call
func ParseGetUnreadCountResponse(rsp *http.Response) (*GetUnreadCountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUnreadCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest []UnreadCount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMarkEntryResponse parses an HTTP response from a MarkEntryWithResponse call
func ParseMarkEntryResponse(rsp *http.Response) (*MarkEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MarkEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMarkEntriesResponse parses an HTTP response from a MarkEntriesWithResponse call
func ParseMarkEntriesResponse(rsp *http.Response) (*MarkEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MarkEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStarEntryResponse parses an HTTP response from a StarEntryWithResponse call
func ParseStarEntryResponse(rsp *http.Response) (*StarEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StarEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTagEntryResponse parses an HTTP response from a TagEntryWithResponse call
func ParseTagEntryResponse(rsp *http.Response) (*TagEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TagEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetTagsResponse parses an HTTP response from a GetTagsWithResponse call
func ParseGetTagsResponse(rsp *http.Response) (*GetTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetFeedEntriesResponse parses an HTTP response from a GetFeedEntriesWithResponse call
func ParseGetFeedEntriesResponse(rsp *http.Response) (*GetFeedEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFeedEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Entries
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetFeedEntriesAsFeedResponse parses an HTTP response from a GetFeedEntriesAsFeedWithResponse call
func ParseGetFeedEntriesAsFeedResponse(rsp *http.Response) (*GetFeedEntriesAsFeedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFeedEntriesAsFeedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExportOpmlResponse parses an HTTP response from a ExportOpmlWithResponse call
func ParseExportOpmlResponse(rsp *http.Response) (*ExportOpmlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportOpmlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetFeedFaviconResponse parses an HTTP response from a GetFeedFaviconWithResponse call
func ParseGetFeedFaviconResponse(rsp *http.Response) (*GetFeedFaviconResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFeedFaviconResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFetchFeedResponse parses an HTTP response from a FetchFeedWithResponse call
func ParseFetchFeedResponse(rsp *http.Response) (*FetchFeedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FetchFeedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest FeedInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetFeedResponse parses an HTTP response from a GetFeedWithResponse call
func ParseGetFeedResponse(rsp *http.Response) (*GetFeedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFeedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Subscription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseImportOpmlResponse parses an HTTP response from a ImportOpmlWithResponse call
func ParseImportOpmlResponse(rsp *http.Response) (*ImportOpmlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ImportOpmlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMarkFeedEntriesResponse parses an HTTP response from a MarkFeedEntriesWithResponse call
func ParseMarkFeedEntriesResponse(rsp *http.Response) (*MarkFeedEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MarkFeedEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseModifyFeedResponse parses an HTTP response from a ModifyFeedWithResponse call
func ParseModifyFeedResponse(rsp *http.Response) (*ModifyFeedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModifyFeedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueueForRefreshResponse parses an HTTP response from a QueueForRefreshWithResponse call
func ParseQueueForRefreshResponse(rsp *http.Response) (*QueueForRefreshResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueueForRefreshResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueueAllForRefreshResponse parses an HTTP response from a QueueAllForRefreshWithResponse call
func ParseQueueAllForRefreshResponse(rsp *http.Response) (*QueueAllForRefreshResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueueAllForRefreshResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSubscribeFromUrlResponse parses an HTTP response from a SubscribeFromUrlWithResponse call
func ParseSubscribeFromUrlResponse(rsp *http.Response) (*SubscribeFromUrlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubscribeFromUrlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSubscribeResponse parses an HTTP response from a SubscribeWithResponse call
func ParseSubscribeResponse(rsp *http.Response) (*SubscribeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubscribeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest int64
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUnsubscribeResponse parses an HTTP response from a UnsubscribeWithResponse call
func ParseUnsubscribeResponse(rsp *http.Response) (*UnsubscribeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnsubscribeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetServerInfosResponse parses an HTTP response from a GetServerInfosWithResponse call
func ParseGetServerInfosResponse(rsp *http.Response) (*GetServerInfosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServerInfosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ServerInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetProxiedImageResponse parses an HTTP response from a GetProxiedImageWithResponse call
func ParseGetProxiedImageResponse(rsp *http.Response) (*GetProxiedImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProxiedImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSendPasswordResetResponse parses an HTTP response from a SendPasswordResetWithResponse call
func ParseSendPasswordResetResponse(rsp *http.Response) (*SendPasswordResetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendPasswordResetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePasswordRecoveryCallbackResponse parses an HTTP response from a PasswordRecoveryCallbackWithResponse call
func ParsePasswordRecoveryCallbackResponse(rsp *http.Response) (*PasswordRecoveryCallbackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasswordRecoveryCallbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUserProfileResponse parses an HTTP response from a GetUserProfileWithResponse call
func ParseGetUserProfileResponse(rsp *http.Response) (*GetUserProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UserModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSaveUserProfileResponse parses an HTTP response from a SaveUserProfileWithResponse call
func ParseSaveUserProfileResponse(rsp *http.Response) (*SaveUserProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SaveUserProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteUserResponse parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResponse(rsp *http.Response) (*DeleteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRegisterUserResponse parses an HTTP response from a RegisterUserWithResponse call
func ParseRegisterUserResponse(rsp *http.Response) (*RegisterUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegisterUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUserSettingsResponse parses an HTTP response from a GetUserSettingsWithResponse call
func ParseGetUserSettingsResponse(rsp *http.Response) (*GetUserSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Settings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSaveUserSettingsResponse parses an HTTP response from a SaveUserSettingsWithResponse call
func ParseSaveUserSettingsResponse(rsp *http.Response) (*SaveUserSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SaveUserSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Retrieve server metrics
	// (GET /rest/admin/metrics)
	GetMetrics(ctx echo.Context) error
	// Delete a user
	// (POST /rest/admin/user/delete)
	AdminDeleteUser(ctx echo.Context) error
	// Get user information
	// (GET /rest/admin/user/get/{id})
	AdminGetUser(ctx echo.Context, id int64) error
	// Get all users
	// (GET /rest/admin/user/getAll)
	AdminGetUsers(ctx echo.Context) error
	// Save or update a user
	// (POST /rest/admin/user/save)
	AdminSaveUser(ctx echo.Context) error
	// Add a category
	// (POST /rest/category/add)
	AddCategory(ctx echo.Context) error
	// Collapse a category
	// (POST /rest/category/collapse)
	CollapseCategory(ctx echo.Context) error
	// Delete a category
	// (POST /rest/category/delete)
	DeleteCategory(ctx echo.Context) error
	// Get category entries
	// (GET /rest/category/entries)
	GetCategoryEntries(ctx echo.Context, params GetCategoryEntriesParams) error
	// Get category entries as feed
	// (GET /rest/category/entriesAsFeed)
	GetCategoryEntriesAsFeed(ctx echo.Context, params GetCategoryEntriesAsFeedParams) error
	// Get root category
	// (GET /rest/category/get)
	GetRootCategory(ctx echo.Context) error
	// Mark category entries
	// (POST /rest/category/mark)
	MarkCategoryEntries(ctx echo.Context) error
	// Rename a category
	// (POST /rest/category/modify)
	ModifyCategory(ctx echo.Context) error
	// Get unread count for feed subscriptions
	// (GET /rest/category/unreadCount)
	GetUnreadCount(ctx echo.Context) error
	// Mark a feed entry
	// (POST /rest/entry/mark)
	MarkEntry(ctx echo.Context) error
	// Mark multiple feed entries
	// (POST /rest/entry/markMultiple)
	MarkEntries(ctx echo.Context) error
	// Star a feed entry
	// (POST /rest/entry/star)
	StarEntry(ctx echo.Context) error
	// Set feed entry tags
	// (POST /rest/entry/tag)
	TagEntry(ctx echo.Context) error
	// Get list of tags for the user
	// (GET /rest/entry/tags)
	GetTags(ctx echo.Context) error
	// Get feed entries
	// (GET /rest/feed/entries)
	GetFeedEntries(ctx echo.Context, params GetFeedEntriesParams) error
	// Get feed entries as a feed
	// (GET /rest/feed/entriesAsFeed)
	GetFeedEntriesAsFeed(ctx echo.Context, params GetFeedEntriesAsFeedParams) error
	// OPML export
	// (GET /rest/feed/export)
	ExportOpml(ctx echo.Context) error
	// Fetch a feed's icon
	// (GET /rest/feed/favicon/{id})
	GetFeedFavicon(ctx echo.Context, id int64) error
	// Fetch a feed
	// (POST /rest/feed/fetch)
	FetchFeed(ctx echo.Context) error
	// get feed
	// (GET /rest/feed/get/{id})
	GetFeed(ctx echo.Context, id int64) error
	// OPML import
	// (POST /rest/feed/import)
	ImportOpml(ctx echo.Context) error
	// Mark feed entries
	// (POST /rest/feed/mark)
	MarkFeedEntries(ctx echo.Context) error
	// Modify a subscription
	// (POST /rest/feed/modify)
	ModifyFeed(ctx echo.Context) error
	// Queue a feed for refresh
	// (POST /rest/feed/refresh)
	QueueForRefresh(ctx echo.Context) error
	// Queue all feeds of the user for refresh
	// (GET /rest/feed/refreshAll)
	QueueAllForRefresh(ctx echo.Context) error
	// Subscribe to a feed
	// (GET /rest/feed/subscribe)
	SubscribeFromUrl(ctx echo.Context, params SubscribeFromUrlParams) error
	// Subscribe to a feed
	// (POST /rest/feed/subscribe)
	Subscribe(ctx echo.Context) error
	// Unsubscribe from a feed
	// (POST /rest/feed/unsubscribe)
	Unsubscribe(ctx echo.Context) error
	// Get server infos
	// (GET /rest/server/get)
	GetServerInfos(ctx echo.Context) error
	// proxy image
	// (GET /rest/server/proxy)
	GetProxiedImage(ctx echo.Context, params GetProxiedImageParams) error
	// send a password reset email
	// (POST /rest/user/passwordReset)
	SendPasswordReset(ctx echo.Context) error

	// (GET /rest/user/passwordResetCallback)
	PasswordRecoveryCallback(ctx echo.Context, params PasswordRecoveryCallbackParams) error
	// Retrieve user's profile
	// (GET /rest/user/profile)
	GetUserProfile(ctx echo.Context) error
	// Save user's profile
	// (POST /rest/user/profile)
	SaveUserProfile(ctx echo.Context) error
	// Delete the user account
	// (POST /rest/user/profile/deleteAccount)
	DeleteUser(ctx echo.Context) error
	// Register a new account
	// (POST /rest/user/register)
	RegisterUser(ctx echo.Context) error
	// Retrieve user settings
	// (GET /rest/user/settings)
	GetUserSettings(ctx echo.Context) error
	// Save user settings
	// (POST /rest/user/settings)
	SaveUserSettings(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetMetrics converts echo context to params.
func (w *ServerInterfaceWrapper) GetMetrics(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMetrics(ctx)
	return err
}

// AdminDeleteUser converts echo context to params.
func (w *ServerInterfaceWrapper) AdminDeleteUser(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdminDeleteUser(ctx)
	return err
}

// AdminGetUser converts echo context to params.
func (w *ServerInterfaceWrapper) AdminGetUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdminGetUser(ctx, id)
	return err
}

// AdminGetUsers converts echo context to params.
func (w *ServerInterfaceWrapper) AdminGetUsers(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdminGetUsers(ctx)
	return err
}

// AdminSaveUser converts echo context to params.
func (w *ServerInterfaceWrapper) AdminSaveUser(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdminSaveUser(ctx)
	return err
}

// AddCategory converts echo context to params.
func (w *ServerInterfaceWrapper) AddCategory(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AddCategory(ctx)
	return err
}

// CollapseCategory converts echo context to params.
func (w *ServerInterfaceWrapper) CollapseCategory(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CollapseCategory(ctx)
	return err
}

// DeleteCategory converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteCategory(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteCategory(ctx)
	return err
}

// GetCategoryEntries converts echo context to params.
func (w *ServerInterfaceWrapper) GetCategoryEntries(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCategoryEntriesParams
	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Required query parameter "readType" -------------

	err = runtime.BindQueryParameter("form", true, true, "readType", ctx.QueryParams(), &params.ReadType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter readType: %s", err))
	}

	// ------------- Optional query parameter "newerThan" -------------

	err = runtime.BindQueryParameter("form", true, false, "newerThan", ctx.QueryParams(), &params.NewerThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter newerThan: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", ctx.QueryParams(), &params.Order)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order: %s", err))
	}

	// ------------- Optional query parameter "keywords" -------------

	err = runtime.BindQueryParameter("form", true, false, "keywords", ctx.QueryParams(), &params.Keywords)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter keywords: %s", err))
	}

	// ------------- Optional query parameter "excludedSubscriptionIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "excludedSubscriptionIds", ctx.QueryParams(), &params.ExcludedSubscriptionIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter excludedSubscriptionIds: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCategoryEntries(ctx, params)
	return err
}

// GetCategoryEntriesAsFeed converts echo context to params.
func (w *ServerInterfaceWrapper) GetCategoryEntriesAsFeed(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCategoryEntriesAsFeedParams
	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Required query parameter "readType" -------------

	err = runtime.BindQueryParameter("form", true, true, "readType", ctx.QueryParams(), &params.ReadType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter readType: %s", err))
	}

	// ------------- Optional query parameter "newerThan" -------------

	err = runtime.BindQueryParameter("form", true, false, "newerThan", ctx.QueryParams(), &params.NewerThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter newerThan: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", ctx.QueryParams(), &params.Order)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order: %s", err))
	}

	// ------------- Optional query parameter "keywords" -------------

	err = runtime.BindQueryParameter("form", true, false, "keywords", ctx.QueryParams(), &params.Keywords)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter keywords: %s", err))
	}

	// ------------- Optional query parameter "excludedSubscriptionIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "excludedSubscriptionIds", ctx.QueryParams(), &params.ExcludedSubscriptionIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter excludedSubscriptionIds: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCategoryEntriesAsFeed(ctx, params)
	return err
}

// GetRootCategory converts echo context to params.
func (w *ServerInterfaceWrapper) GetRootCategory(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRootCategory(ctx)
	return err
}

// MarkCategoryEntries converts echo context to params.
func (w *ServerInterfaceWrapper) MarkCategoryEntries(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.MarkCategoryEntries(ctx)
	return err
}

// ModifyCategory converts echo context to params.
func (w *ServerInterfaceWrapper) ModifyCategory(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ModifyCategory(ctx)
	return err
}

// GetUnreadCount converts echo context to params.
func (w *ServerInterfaceWrapper) GetUnreadCount(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUnreadCount(ctx)
	return err
}

// MarkEntry converts echo context to params.
func (w *ServerInterfaceWrapper) MarkEntry(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.MarkEntry(ctx)
	return err
}

// MarkEntries converts echo context to params.
func (w *ServerInterfaceWrapper) MarkEntries(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.MarkEntries(ctx)
	return err
}

// StarEntry converts echo context to params.
func (w *ServerInterfaceWrapper) StarEntry(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.StarEntry(ctx)
	return err
}

// TagEntry converts echo context to params.
func (w *ServerInterfaceWrapper) TagEntry(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TagEntry(ctx)
	return err
}

// GetTags converts echo context to params.
func (w *ServerInterfaceWrapper) GetTags(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTags(ctx)
	return err
}

// GetFeedEntries converts echo context to params.
func (w *ServerInterfaceWrapper) GetFeedEntries(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFeedEntriesParams
	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Required query parameter "readType" -------------

	err = runtime.BindQueryParameter("form", true, true, "readType", ctx.QueryParams(), &params.ReadType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter readType: %s", err))
	}

	// ------------- Optional query parameter "newerThan" -------------

	err = runtime.BindQueryParameter("form", true, false, "newerThan", ctx.QueryParams(), &params.NewerThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter newerThan: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", ctx.QueryParams(), &params.Order)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order: %s", err))
	}

	// ------------- Optional query parameter "keywords" -------------

	err = runtime.BindQueryParameter("form", true, false, "keywords", ctx.QueryParams(), &params.Keywords)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter keywords: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFeedEntries(ctx, params)
	return err
}

// GetFeedEntriesAsFeed converts echo context to params.
func (w *ServerInterfaceWrapper) GetFeedEntriesAsFeed(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFeedEntriesAsFeedParams
	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Required query parameter "readType" -------------

	err = runtime.BindQueryParameter("form", true, true, "readType", ctx.QueryParams(), &params.ReadType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter readType: %s", err))
	}

	// ------------- Optional query parameter "newerThan" -------------

	err = runtime.BindQueryParameter("form", true, false, "newerThan", ctx.QueryParams(), &params.NewerThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter newerThan: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", ctx.QueryParams(), &params.Order)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order: %s", err))
	}

	// ------------- Optional query parameter "keywords" -------------

	err = runtime.BindQueryParameter("form", true, false, "keywords", ctx.QueryParams(), &params.Keywords)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter keywords: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFeedEntriesAsFeed(ctx, params)
	return err
}

// ExportOpml converts echo context to params.
func (w *ServerInterfaceWrapper) ExportOpml(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ExportOpml(ctx)
	return err
}

// GetFeedFavicon converts echo context to params.
func (w *ServerInterfaceWrapper) GetFeedFavicon(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFeedFavicon(ctx, id)
	return err
}

// FetchFeed converts echo context to params.
func (w *ServerInterfaceWrapper) FetchFeed(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.FetchFeed(ctx)
	return err
}

// GetFeed converts echo context to params.
func (w *ServerInterfaceWrapper) GetFeed(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFeed(ctx, id)
	return err
}

// ImportOpml converts echo context to params.
func (w *ServerInterfaceWrapper) ImportOpml(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ImportOpml(ctx)
	return err
}

// MarkFeedEntries converts echo context to params.
func (w *ServerInterfaceWrapper) MarkFeedEntries(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.MarkFeedEntries(ctx)
	return err
}

// ModifyFeed converts echo context to params.
func (w *ServerInterfaceWrapper) ModifyFeed(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ModifyFeed(ctx)
	return err
}

// QueueForRefresh converts echo context to params.
func (w *ServerInterfaceWrapper) QueueForRefresh(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.QueueForRefresh(ctx)
	return err
}

// QueueAllForRefresh converts echo context to params.
func (w *ServerInterfaceWrapper) QueueAllForRefresh(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.QueueAllForRefresh(ctx)
	return err
}

// SubscribeFromUrl converts echo context to params.
func (w *ServerInterfaceWrapper) SubscribeFromUrl(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SubscribeFromUrlParams
	// ------------- Required query parameter "url" -------------

	err = runtime.BindQueryParameter("form", true, true, "url", ctx.QueryParams(), &params.Url)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter url: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SubscribeFromUrl(ctx, params)
	return err
}

// Subscribe converts echo context to params.
func (w *ServerInterfaceWrapper) Subscribe(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Subscribe(ctx)
	return err
}

// Unsubscribe converts echo context to params.
func (w *ServerInterfaceWrapper) Unsubscribe(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Unsubscribe(ctx)
	return err
}

// GetServerInfos converts echo context to params.
func (w *ServerInterfaceWrapper) GetServerInfos(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetServerInfos(ctx)
	return err
}

// GetProxiedImage converts echo context to params.
func (w *ServerInterfaceWrapper) GetProxiedImage(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProxiedImageParams
	// ------------- Required query parameter "u" -------------

	err = runtime.BindQueryParameter("form", true, true, "u", ctx.QueryParams(), &params.U)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter u: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProxiedImage(ctx, params)
	return err
}

// SendPasswordReset converts echo context to params.
func (w *ServerInterfaceWrapper) SendPasswordReset(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SendPasswordReset(ctx)
	return err
}

// PasswordRecoveryCallback converts echo context to params.
func (w *ServerInterfaceWrapper) PasswordRecoveryCallback(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PasswordRecoveryCallbackParams
	// ------------- Required query parameter "email" -------------

	err = runtime.BindQueryParameter("form", true, true, "email", ctx.QueryParams(), &params.Email)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter email: %s", err))
	}

	// ------------- Required query parameter "token" -------------

	err = runtime.BindQueryParameter("form", true, true, "token", ctx.QueryParams(), &params.Token)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter token: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PasswordRecoveryCallback(ctx, params)
	return err
}

// GetUserProfile converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserProfile(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUserProfile(ctx)
	return err
}

// SaveUserProfile converts echo context to params.
func (w *ServerInterfaceWrapper) SaveUserProfile(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SaveUserProfile(ctx)
	return err
}

// DeleteUser converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteUser(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteUser(ctx)
	return err
}

// RegisterUser converts echo context to params.
func (w *ServerInterfaceWrapper) RegisterUser(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RegisterUser(ctx)
	return err
}

// GetUserSettings converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserSettings(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUserSettings(ctx)
	return err
}

// SaveUserSettings converts echo context to params.
func (w *ServerInterfaceWrapper) SaveUserSettings(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SaveUserSettings(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/rest/admin/metrics", wrapper.GetMetrics)
	router.POST(baseURL+"/rest/admin/user/delete", wrapper.AdminDeleteUser)
	router.GET(baseURL+"/rest/admin/user/get/:id", wrapper.AdminGetUser)
	router.GET(baseURL+"/rest/admin/user/getAll", wrapper.AdminGetUsers)
	router.POST(baseURL+"/rest/admin/user/save", wrapper.AdminSaveUser)
	router.POST(baseURL+"/rest/category/add", wrapper.AddCategory)
	router.POST(baseURL+"/rest/category/collapse", wrapper.CollapseCategory)
	router.POST(baseURL+"/rest/category/delete", wrapper.DeleteCategory)
	router.GET(baseURL+"/rest/category/entries", wrapper.GetCategoryEntries)
	router.GET(baseURL+"/rest/category/entriesAsFeed", wrapper.GetCategoryEntriesAsFeed)
	router.GET(baseURL+"/rest/category/get", wrapper.GetRootCategory)
	router.POST(baseURL+"/rest/category/mark", wrapper.MarkCategoryEntries)
	router.POST(baseURL+"/rest/category/modify", wrapper.ModifyCategory)
	router.GET(baseURL+"/rest/category/unreadCount", wrapper.GetUnreadCount)
	router.POST(baseURL+"/rest/entry/mark", wrapper.MarkEntry)
	router.POST(baseURL+"/rest/entry/markMultiple", wrapper.MarkEntries)
	router.POST(baseURL+"/rest/entry/star", wrapper.StarEntry)
	router.POST(baseURL+"/rest/entry/tag", wrapper.TagEntry)
	router.GET(baseURL+"/rest/entry/tags", wrapper.GetTags)
	router.GET(baseURL+"/rest/feed/entries", wrapper.GetFeedEntries)
	router.GET(baseURL+"/rest/feed/entriesAsFeed", wrapper.GetFeedEntriesAsFeed)
	router.GET(baseURL+"/rest/feed/export", wrapper.ExportOpml)
	router.GET(baseURL+"/rest/feed/favicon/:id", wrapper.GetFeedFavicon)
	router.POST(baseURL+"/rest/feed/fetch", wrapper.FetchFeed)
	router.GET(baseURL+"/rest/feed/get/:id", wrapper.GetFeed)
	router.POST(baseURL+"/rest/feed/import", wrapper.ImportOpml)
	router.POST(baseURL+"/rest/feed/mark", wrapper.MarkFeedEntries)
	router.POST(baseURL+"/rest/feed/modify", wrapper.ModifyFeed)
	router.POST(baseURL+"/rest/feed/refresh", wrapper.QueueForRefresh)
	router.GET(baseURL+"/rest/feed/refreshAll", wrapper.QueueAllForRefresh)
	router.GET(baseURL+"/rest/feed/subscribe", wrapper.SubscribeFromUrl)
	router.POST(baseURL+"/rest/feed/subscribe", wrapper.Subscribe)
	router.POST(baseURL+"/rest/feed/unsubscribe", wrapper.Unsubscribe)
	router.GET(baseURL+"/rest/server/get", wrapper.GetServerInfos)
	router.GET(baseURL+"/rest/server/proxy", wrapper.GetProxiedImage)
	router.POST(baseURL+"/rest/user/passwordReset", wrapper.SendPasswordReset)
	router.GET(baseURL+"/rest/user/passwordResetCallback", wrapper.PasswordRecoveryCallback)
	router.GET(baseURL+"/rest/user/profile", wrapper.GetUserProfile)
	router.POST(baseURL+"/rest/user/profile", wrapper.SaveUserProfile)
	router.POST(baseURL+"/rest/user/profile/deleteAccount", wrapper.DeleteUser)
	router.POST(baseURL+"/rest/user/register", wrapper.RegisterUser)
	router.GET(baseURL+"/rest/user/settings", wrapper.GetUserSettings)
	router.POST(baseURL+"/rest/user/settings", wrapper.SaveUserSettings)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9bY/cuJHwXyH6eQDngE7GsZPgbr5NvHZucvatb2zjDlgsArZU3c0ditSS1PQ0FvPf",
	"D3yTKKkoqWfdHm/O3+wmRRbrnfXC+WVVyKqWAoTRq8tfVrrYQ0XdP6/K8hU1sJPqeAM/N6CN/bUEXShW",
	"GybF6tLOIXESibPWq1rJGpRh4BYStILxp+7X9aqi929B7Mx+dfnHF/+6XpljDavLlTaKid3qYb2qqQJh",
	"rsvxCn6EFHF/Vq4J2xIqjvPrPqxXCn5umIJydfmDB+bHdpbc/ASFsbtflRUTH+gdfNKgsmiwE4idQZjY",
	"SlVR9/sQD9SuNf64cd9p4odbGDZScqDCAgEVZTzzoRtLzj3CHwi64YCgjxaFbIQh2lDTaHRjVubALVfr",
	"lT/p6nLFhPnLn7oFmDCwA2UXwEnvlgj0R+it9UGq3M7t8BxJIzrj+dd5IkcOHm/5Whh1JCUYyrgeEbTY",
	"M14qQGja8mScErnUfrleMQOVW+H/K9iuLlf/76KTwosgghctVA8tyFQp6v4P9zUVJUbVwx7MHhQxe0gk",
	"Q5P4BZGKFJJzWmsoUaJvAUo9cSQ/vvAQH5pNtwhyEIzDEoHGGATnqZmPTtEi+e//E916uEKWs6Vm/pPR",
	"CmGEyO2AcML9nzOnVlOBe/kCEbiBCLT8mTBMpK9D/Tpq4Ra0KfF4J0u2ZYVTbllV2FqDKplNVMY0YOT/",
	"dbpFwMERYE1Ew7nVi0IaUuyp2LnT/wp7Y5dGuWV+zSzl7Zol0zWnRxJn5UA/lfysxMkZpD9LwndU3WaN",
	"edQdiATGkaWWpI/EWYoPmbvbLnNQq7wD1P2N3zJtrKiBn0AOzOyJlhWQCgwtqaGjY0NuLd5fa6ledIYF",
	"1exKSfXKGubxXoZVoJ1C0KDurJJXDEpiJFGwVaD3bszKN6GiJFvK+DLG8UrhLRO3400/3byNaukAG80M",
	"rAncG0ULAyXZKlm1u66JFPxItoxzKC3//tyAOjKxI1upPFwBTWvP2pEBOuSNRGdP9TupEHZjHia3BdlT",
	"TSqpgACHyvmyKBPuhFRQ3gAtP3inB11VNbB2azdCAS3JltMdOVBNwvdRKweltiaU85aXqLIDplECSqJg",
	"R1XJQeuAQqaIW3LC5+KsYhjtuw2hJH7SIspWoDXdIQh0nGbdgQNVwhIpzlxsc+2vkTccdeXA72gBxtaU",
	"262G2ZOGWYuO6uTD0KrOiOkOBChvkLqpp2uejlsTYe04FeOz1tB2++Y01sleKG3MXiqEvu6rMIrgP/FI",
	"EV1eVfT3GmqqqOc3r+V6Xux4RSkMYIrLgxKHkS9LaiD3Wd1sePQj3Dz0klNwqRsFH90IvlA7iVSsAmIX",
	"mb44hemfFJ9fslGTtzArHphP4cQGdznzKtnsrUNvAXimo1K2AORWwd1Wt3XOV7WD6Ll7e7slMhvvGszm",
	"e7S5MeQbVkiB7vrRahh6Z8ftftbkNRqcWXEAWUDQBbMgZAAQGpSB8rsJfvRzIjdGY2C9hg3VKDIrqm7t",
	"JXT6thZW10QbxjmJH5HfSV6GQW82gpUpmS6oKqH8F9SOVFAy+l26G34cN48kI1Ns7CZ/3DfVRlDG/x3Y",
	"bm+mFzZxMtm72cnqi4xXut+EIA43mxHH/rr/zUrruy9b+WAnn3YKa/LHy885AsrwPMP0NKrz9gwzHLz7",
	"YTi6oDZUKSxmEAamgDF0h5gJ92vi8aKjI+QPXV4HeQ79fhBZpckzA6qRRteHaIyCTQkaOtG7ifLsFGJQ",
	"bJ2uChfpnuZIRD5Q35Ozo8G6xU44n4UZcwneWLDEVo7PakeyTkEGp6dhcwkel8KfvW26YyRh02ysAAUx",
	"sUDJLfxPz//tL3OATwG8KNLhAF8U5Yj+8OcNKmwZN4D4fX9//T9viZ9G4I7yxnlwUhC7VbymGOkMjDU8",
	"FaHa30r8lepISumuZxU1xX4BYtdfZRjnawq5XH+XcBEWATv1CpLZ5x1Vt48L68B9wZsSyjRei1+PLdtY",
	"1qIdv0pFnlHOn61JWIaYvdRAdLpYFyoIK+QNx2feZQETLglLR79x3c84OZgccEG3P1vCntFc/BW2aHSj",
	"ptpHetoLIznKhuyk6U7oAXJXMyMJvZOsbPHWyvmeWkE+kj29A7IBEGQLpth3UYwKqL8OOy9CwB2oKB6w",
	"UIRv4XiQCksauHiQUzRRwVB/adhTdzwNJH4c4fF+jFREaZ1cGWcxKnkJ6uOeIhLvAHCgRLS4yRY5wt0f",
	"lh0Td+Pc4lGDShWCRogTNRbhsCQqyQ03rOYwLdFhEpkU7WCVJmKXgUBh2sIIZgrZSIIGZ23Xxo76PmT0",
	"bkCDyerJTA7U/UxoWSrQ2t0HY4KQKCjkHahBMvjFn/885xn4rVBQldwyDovcgzB3oYfQKOsCvM/mPsME",
	"0suBrkkE2yoAb7VIHfYNYexZuckg1q+mfX45Bvns7u7qo2so2JYNTTGG3LU1uFc1+w9AIlshIgeEOu+E",
	"1szqA/QGIuAwgZ4AbUv8KYBnLgYDUmB8cAM7po0aMsCX49ipzLp3mzZgDlbbv3Rq/eULyx4uZq90f/mX",
	"L9arion2vyel5DtOrJhgVVORv/Q3WiJpXRZyCucfXMoDvwr5MXeLQOKjnMtDSjF/QRoxGBVCNqJw+YNk",
	"RhKkhEpe+aKJ111RxXihHTOvZBWi+OO4mJQ7DleC8qNhhX4lS0Dn6crUk9sYBXADXNLyWhhQd5Qv8iTX",
	"qztQOnjGo10PsNGyuIXpE7az3jOxO2n3YZHGmDYonlOk9lGD4qE7I3KiHPg40xnDBBb6cNU+Og6P9bk2",
	"snplvZd78w5EgwRd9vJAXJzdOkTPNJEH4f2de0MqEI29sim22xtScFbcokox7KM1rgqeaeJnkCLomiSN",
	"h0bw3ey/zy7306LV4N5YdcTfMnF7XUjxnXcr3wWWz4RCJXGocR5uWIBwJm6Ji/4GL3EP1HpwvcQriKby",
	"THWgR712ruxain+UoG+NrO0/K7lhPC0C6oDlVOwaNFEWjl4r2IKLk8WpawJix5ne+4ujyAZ/rzi/0jdA",
	"y1dSbFmsDxtXZOlbh9YimUUOexDddSjNNHqfEw/+unO+kRKNEEhB/IS1RzUt3E6bxhh7haLGoXgjjSV1",
	"sKS6UAB4eZqFgokdTlbnsNgZugd86yh3vwh+7BGRr4MrjVEr7Pm9KrEDJpvG5ZkgVBcg7Fd2d/tB+z+7",
	"SLK1LtZ2GN1YF0pybp1fREiuRVdndcfgsCZ+OjF7JZvdvoVmFHvBA7Z+r1lxCXvIUBrAwaXm3fUwJxZs",
	"+w8BUEI5ccgPNUC5QBzC/tpO9+wq6B3bUasaWz+kE9MFAXO9pxaUVPtOFpkNprsVrF2huSrCAxVGd/d4",
	"Vy0BUIZSECGHzGmXE9mg+qN0m/3wzCrNH8Llp9/45FnGDIXT+nrQAE5It6GHThb+iAeas8sOItC52/HY",
	"gE6bk0R/T6ncgWbs666BVunLek8a+xIy5teE/3AOQWmD4BX1ScbCgbkmflbeRdk0263XnRMFx0h1KC1g",
	"I+VtxvXNf8iENrSmdW7P2nlkGVe3qTY88505MGPwRQc8FU68bq8d7Vki4D0oW5Da/bvNULoYOlEhbqU9",
	"F6GZLw5Y4NVnY/CzEYDZvKBUREgzL7RtCo2VSaoLxZWP2W7yRYhpIPpRiRXWCwJ0ut5IUnNaQFe15MrE",
	"Z7GUyaiNaqCiX2x3XbJuLvOWLnp6dmsuLdery8Y1yFQrwxTiZyqppwocfUlaEQqqflXZoisLSVMDy0pl",
	"8jUvg7WmSl++WGbuaQpoUkwsVk+canPjq1SRQDTVxucgWjE6uKO7+ThkM3WNYZgc9oyDz3lYtCcStTCk",
	"1jttrlxKwAG0uTZQfWTYIq5SKAi0n0uYgQpf6j6PKDs4QFQs/WXa6jUhoOySmckY5ZaRjuTnBhr8+Mvb",
	"EwaicGKTQnRzEK2X+IuPqctMqzEHVRyhUqNfsxGoObpmdmryI91lLdRHusunU+3d63q6+GxJWvJsVTdI",
	"Sevxui1LwVDxqfNNEYPRp1zOvVlSDjCSpDBHNNUmZZ8WkiVsMj6NBmU9cf4I4/foPj6ayYKM0h5JQE6B",
	"NRL57j03YVwa22Hrt9s8aK3CW7nDcO0MBrdj2XOfr/VwHbLkbZn/5ugUIK3ZI7oS2URronXOoWgUM8cP",
	"xR6qcHOjmhVXjS9ZdDEQh3n7a7f/3ph69fDgLl4+ZRIc2NUrWVXUFS9dvb9OQuWXK5dGr0HYg1yuXv7h",
	"+R/+6LIyZu/2vVCgzYU7wUUFRrHC/bzztzYrIY4Traiv/gbmXZhiEaBrKXQsNN/ShhvfS9TWi9O6jkXe",
	"Fz9pZ4QeXMqlZ0X9pySu5xHUVBVVx9Xl6sZuCHdtd0zVAuD16A++m3f1o/0sPYyl7kUJHHzRby0xdf+d",
	"Gyc05BSpKF1Ac+ga2u36qHCb+q8/6RB0cFbjr7I8zqMhtGTPxcC6EqOHPs8Z1cDDF6NBD0sLMb8Dc/EL",
	"Kx8SZurv+TcIie++VkbQ/DcwAcc1VbQCl4W8/CGvhpjPYpp9FMLLWJiR4m+dEGHe3Pz4WGwvJHVnux4e",
	"Hvroz2BqIRWuOJ+kgeV3O1dPIv/xEp+cf1EJSoKIkX+DICYFfwlGNL2b0Aeu518q0tQlbTn+D+Tau8is",
	"tK6Avau1lQfrUOTgA9CMc7IBEu07itD47sCZVAb6tsGTag8Up1PUirGGC1qWeVJdlWXAvbsxxY8QpLcv",
	"XpwN5aM3NT4nwk9SUwMJ8UhKcBOR/ibBmfWAMfSnXcET4tI+PGCJ3GbKvA/pYhE0T5zYtnxmCg27o59U",
	"HiIwjyfMUq9GELhn2mXspmXEf3BmInxtzswjkZ80jedt6rC3Mu2GHvnUEe+v2ymTfk4XA4+LZ+qVnRvk",
	"WqkX+0Gje87oithP97v62xDhkcJ3yiO72nHXxDm1d0vyVVttm9QNYCGdPJi9umABh0FdMAajm+VKjU9z",
	"DMd7u+bmUAS4CzXxyIZtEzSCgueLuhTGpb8VSzdekygLL56vSUXvXTHfH58/f54BKXagIxC9eBxIrgxj",
	"AgdtUnbMBa5ao1fAsfKivogDNFBV7B0y0mJ0YG1rZluT7kQpNN0FyWpfNOi6pTdHomta2B9fJuWQsUYy",
	"c8C2iv4kKct1aseGDjKI1ud4GmsAuT4VmFuAul9ob+huB6Uvq3CJBkNzBPYj+d3Ofa2KOhW9O2BPVZxu",
	"Ca70m1BSM2EP/EsKj7IHYf3/81bBG4FvJuG3bhJ82uybXfhmFz6rXbiv+GOuA5gdILTLnZ9gD4L6n4y0",
	"dUu4YHO/zTEpbcHswo2UpndHO6Pd7N4pxAynkslDTydiqaLqNn91dU1v6aNSHiksretsi2v7GLKfjq9S",
	"57jJ9rrkxhzX6ySNDa6rp7vxOpz+Sl/HNbwd83S7AVcztTzk4NrtjueO+0w8cvikQYiIrscK0SBbnsvW",
	"pen9Lxa/T/ZcFMHvFRS3b8oN028LsOPqHZboF9ppmFadXLRBh7FWeR2K7p9AlwyagJ9UhaRoG1IkahWU",
	"HLGl+RS1v5AsZ1TySLM2RqBMu/aTUqqKQKUoXUwye1n8jBL0wVB1TglKS7QRAg2KtJ8sC2bBeJQEWVc5",
	"oUYfuR/p7py4TUrlENT2i+WeDLP2Zt1xYyyVW4rb6Uh+vGHZicMq8JG5/ei3/kLnngNvDgMWZydmMwbq",
	"ZIQAu9XJWYxw0/qWrfgWmvqWrfgNRKWeNGQ/4dBkldtJAfoTVNypgfnfuqL7FoD/FoD/purOFoUeXn8p",
	"FoNGlNx9LVU+8PzaDRMqyPfv370l7hWpJM78bK7Q2X//fV3x1ZdChgM0HGvu9KH9bbrU+A2YYh/w+UyT",
	"0JeNqvaubXtSqY+75b6qmuOTUY5jaAb19pt8nCBd0sooMzq0VvYR7+YFQ3qOK+zwrVrkHpu0fX7+ms0l",
	"sI19nRR7s5RAau1R5v7nrqDv/1WqIUJ3QcPOIpNVUZ/ifH1djRTqmtipUHqt/eb7m3cxBwrkmZ3wLHYn",
	"9cnil2p1a473fTSPKnNhkfx79wZgDytDszVicFnV3EH6hGEah62A3DkanJojjB3Vvws+b6zSb2q7nX9M",
	"fxw/7kcrniq4r76OkPFJF6u5bKBP7kXlnxrLTB7wzPo/m/+bs+pPRpKIwAHupsmiug7znOSIhnJ+JNT1",
	"BTjqhBemYle5ayUfUem/7K9vpIo97F+kQhx7Uv4pieKQENFm7y+qxcYiukx1YvUpw3l4uSp97GQ5oa44",
	"H9DqS+IHBf4UdOn4jkwWW+1LM+6N7GjXB2mnOOeNkpV/H2DS+UmcQOy+iLmHZ4mSnZ7/QJExRPE618Jz",
	"CirPlcEbPhw0p5s/u838NT1Wy/DfZ/FG9JgcJ82nbpJ/Hz5DnmTeP3frTh4hWWz7rvHZ0jzdf2t4dHvq",
	"3inW5668S55ERiPgA1Djyf1nyNFrJe+PUzfD90reMyivK//O3nQw206a0pJn0JFuz4ta7B7DMu70hIWz",
	"5ZHleoPr9NH6fM79A4iy9779maQOfUP/SQVQg7B+Y/K2uQZD4st7Ebu+X3wSua8o5xta3Gb5sju7fz29",
	"/WDEoGh9c4DopIwKWqYsb937uJ+bpw3cm4u9OSU+OoNd/wcCJosBNajw9wtWT/eYQfueR/vibIRoeMB1",
	"TvxCc3t6ljMIX/6vQjx9N/0s7lDmCH3D4RX2vH4bPGvyJbty2/tCeIpo9mjKPTMPKn+amzDjjG8uYH85",
	"4onLi/2Z41/gWIhMnbw+i7pKPeFNX6FFlU3ycu6ZPab4RPSksknhzesa5IGD6cNGddQ77RnuSMkhvwLt",
	"M4XM9IUrZ6KTt61++NFaSO+aYg7m8B0r95Dq6mL18OPD/wYAAP//zs3LCtaGAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
